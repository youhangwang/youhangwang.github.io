<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh" /><updated>2022-01-13T18:11:45+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Johan Blog</title><subtitle>Johan Blog
</subtitle><author><name>Johan Wang</name><email>youhangwang@foxmail.com</email></author><entry><title type="html">Container Storage Interface（CSI) In Kubernetes</title><link href="http://localhost:4000/2022/01/12/K8s-CSI.html" rel="alternate" type="text/html" title="Container Storage Interface（CSI) In Kubernetes" /><published>2022-01-12T00:00:00+08:00</published><updated>2022-01-12T00:00:00+08:00</updated><id>http://localhost:4000/2022/01/12/K8s-CSI</id><content type="html" xml:base="http://localhost:4000/2022/01/12/K8s-CSI.html">&lt;p&gt;&lt;a href=&quot;./2021-10-29-CSI.md&quot;&gt;CSI&lt;/a&gt;是一套通用的RPC接口，可以将Block和File System暴露给Kubernetes等容器编排系统(CO)上运行的容器化工作负载。通过使用CSI，第三方存储提供商可以编写和部署插件，在Kubernetes中公开新的存储系统，而无需接触Kubernetes的核心代码。
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;development-and-deployment&quot;&gt;Development And Deployment&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://groups.google.com/forum/#!forum/container-storage-interface-drivers-announce&quot;&gt;container-storage-interface-drivers-announce&lt;/a&gt;会发布可能影响现有CSI Driver实现的CSI或Kubernetes的更改。&lt;/p&gt;

&lt;p&gt;Kubernetes没有具体规定如何打包和部署CSI Driver，但是对Kubernetes（Master和Node）组件如何找到CSI Driver并与之通信规定了以下内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kubelet与CSI Driver的通信:
    &lt;ul&gt;
      &lt;li&gt;Kubelet通过插件注册机制发现 CSI Driver。&lt;/li&gt;
      &lt;li&gt;Kubelet通过Unix Domain Socket直接向CSI Driver发出调用（如 NodeStageVolume、NodePublishVolume 等）以挂载和卸载卷。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Master与CSI Driver的通信:
    &lt;ul&gt;
      &lt;li&gt;Kubernetes Master组件不与CSI Driver直接通信（例如通过 Unix Domain Socket或其他方式）。&lt;/li&gt;
      &lt;li&gt;Kubernetes Master组件仅与Kubernetes API交互。&lt;/li&gt;
      &lt;li&gt;因此，基于Kubernetes API的操作（如卷创建、卷附加、卷快照等）的CSI Driver必须监视Kubernetes API并触发适当的CSI操作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些要求是最低限度的规定，CSI Driver开发人员可以自由地实施和部署他们认为合适的Driver。但是为了简化开发和部署，推荐使用以下组件开发CSI Driver：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Kubernetes CSI Sidecar 容器&lt;/li&gt;
  &lt;li&gt;Kubernetes CSI 对象&lt;/li&gt;
  &lt;li&gt;CSI Driver测试工具&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要使用此机制实现CSI Driver，CSI Driver开发人员应该：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建一个容器化应用程序，实现CSI规范中定义的Identify、Node Service和可选的Controller Service。&lt;/li&gt;
  &lt;li&gt;使用csi-sanity进行单元测试。&lt;/li&gt;
  &lt;li&gt;定义Kubernetes API YAML 文件，用于部署 CSI Driver和适当的Sidecar Container。&lt;/li&gt;
  &lt;li&gt;在Kubernetes集群上部署CSI Driver并在其上运行E2E功能测试。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;创建CSI Driver的第一步是编写实现CSI Spec中描述gRPC接口的应用程序，CSI Driver至少须实现以下两种CSI服务：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CSI Identity
    &lt;ul&gt;
      &lt;li&gt;使调用者（Kubernetes组件和CSI sidecar container）能够识别Driver及其支持的可选功能。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CSI Node Service
    &lt;ul&gt;
      &lt;li&gt;仅其中的NodePublishVolume、NodeUnpublishVolume和NodeGetCapabilities是必须实现的。&lt;/li&gt;
      &lt;li&gt;必需的方法使调用者能够在指定的路径上提供可用的Volume并发现Driver支持哪些可选功能。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所有CSI服务都可以在同一个CSI Driver应用程序中实现。CSI Driver应用程序应该被容器化，以便在Kubernetes上轻松部署。容器化后，CSI Driver可以与CSI Sidecar Containers配对使用，并根据需要以Node和/或Controller模式部署。如果Driver支持附加功能，CSI capabilities可用于告知调用者它支持的可选方法/服务，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CONTROLLER_SERVICE（PluginCapability）
    &lt;ul&gt;
      &lt;li&gt;整个CSI Controller Service是可选的。此功能指示Driver实现了CSI Controller Service中的一个或多个方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VOLUME_ACCESSIBILITY_CONSTRAINTS（PluginCapability）
    &lt;ul&gt;
      &lt;li&gt;此功能表明该Driver支持的Volume可能无法从集群中的所有节点同等访问，并且该Driver将返回额外的拓扑相关信息，Kubernetes 可以使用这些信息更智能地调度工作负载或影响配置Volume的位置。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VolumeExpansion (PluginCapability)
    &lt;ul&gt;
      &lt;li&gt;此功能表明Driver支持在创建后调整（扩展）卷的大小。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CREATE_DELETE_VOLUME（ControllerServiceCapability）
    &lt;ul&gt;
      &lt;li&gt;此功能表明Driver支持动态卷配置和删除。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PUBLISH_UNPUBLISH_VOLUME（ControllerServiceCapability）
    &lt;ul&gt;
      &lt;li&gt;此功能表明Driver实现了ControllerPublishVolume和ControllerUnpublishVolume —— 对应于 Kubernetes 卷附加/分离操作的操作。例如，这可能会导致针对 Google Cloud 控制平面的“卷附加”操作，以将指定卷附加到 Google Cloud PD CSI Driver的指定节点。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CREATE_DELETE_SNAPSHOT (ControllerServiceCapability)
    &lt;ul&gt;
      &lt;li&gt;此功能表明Driver支持供应卷快照以及使用这些快照供应新卷的能力。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CLONE_VOLUME（ControllerServiceCapability）
    &lt;ul&gt;
      &lt;li&gt;此功能表明Driver支持克隆卷。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;STAGE_UNSTAGE_VOLUME（NodeServiceCapability）
    &lt;ul&gt;
      &lt;li&gt;此功能表明Driver实现了NodeStageVolume 和NodeUnstageVolume —— 对应于 Kubernetes 卷设备挂载/卸载操作的操作。例如，这可以用于创建块存储设备的全局（每个节点）卷安装。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;kubernetes-csi-sidecar-containers&quot;&gt;Kubernetes CSI Sidecar Containers&lt;/h2&gt;

&lt;p&gt;Kubernetes CSI Sidecar Containers是一组标准容器，目标是简化Kubernetes上CSIDriver的开发和部署。这些容器包含Watch Kubernetes API 对象的通用逻辑，触发针对CSI Driver容器的适当操作，并根据需要更新 Kubernetes API。使用这些Side Car的好处包括：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;CSI Driver开发人员不必担心复杂的Kubernetes代码。&lt;/li&gt;
  &lt;li&gt;与 Kubernetes API 交互的代码与实现 CSI 接口的代码隔离（在不同的容器中）。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Kubernetes 开发团队维护以下 Kubernetes CSI Sidecar Containers：&lt;/p&gt;

&lt;h3 id=&quot;external-provisioner&quot;&gt;&lt;a href=&quot;https://github.com/kubernetes-csi/external-provisioner&quot;&gt;external-provisioner&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;CSI external-provisioner 是一个 sidecar 容器，用于监视 Kubernetes Apiserver 以获取 PersistentVolumeClaim 对象。它调用指定的 CSI Driver的CreateVolume接口以供应新卷或者DeleteVolume删除卷。在 Kubernetes controller-manager中运行的内部persistent volume controller没有任何与 CSI Driver的直接接口。&lt;/p&gt;

&lt;p&gt;如果PVC引用了StorageClass，并且StorageClass的Provisioner字段与GetPluginInfo接口中返回的名称匹配，则卷由PersistentVolumeClaim对象的创建触发。当成功配置新卷后，sidecar容器会创建一个 Kubernetes PersistentVolume 对象来表示该卷。&lt;/p&gt;

&lt;p&gt;一旦与此PersistentVolume绑定了PersistentVolumeClaim被删除，对应CSI driver的DeleteVolume接口会被调用。当该卷被成功删除时，side car也会删除代表该卷的PersistentVolume对象。&lt;/p&gt;

&lt;h4 id=&quot;data-source&quot;&gt;Data Source&lt;/h4&gt;

&lt;p&gt;external-provisioner提供了从一个data source部署volume的能力。支持的data source 包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Snapshot
  如果将Snapshot CRD 指定为 PVC 对象上的数据源，则side car通过获取&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SnapshotContent&lt;/code&gt;对象来获取有关快照的信息，并在调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateVolume&lt;/code&gt;时填充data source字段以向存储系统指示新卷应使用指定的快照填充。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PersistentVolumeClaim(clone)
  克隆也是通过在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateVolume&lt;/code&gt;调用中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DataSource&lt;/code&gt;字段中指定一种类型为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PersistentVolumeClaim&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kind&lt;/code&gt;来实现的。外部供应商有责任验证在 DataSource 中指定的对象是否存在，是否与正在供应的卷在同一存储类中，并且当前状态是绑定的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;storageclass-参数&quot;&gt;StorageClass 参数&lt;/h4&gt;
&lt;p&gt;Provision新卷时，CSI external-provisioner将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateVolumeRequest&lt;/code&gt;调用中的parameters(map&amp;lt;string, string&amp;gt;)字段设置为它正在处理的 StorageClass中指定的键/值。&lt;/p&gt;

&lt;p&gt;CSI external-provisioner (v1.0.1+) 还保留了前缀为 csi.storage.k8s.io/ 的参数键。任何以 csi.storage.k8s.io/ 为前缀的 StorageClass 键都不会传递给 CSI Driver。y&lt;/p&gt;

&lt;p&gt;以下保留的 StorageClass 参数键会触发 CSI external-provisioner的行为：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;csi.storage.k8s.io/provisioner-secret-name&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/provisioner-secret-namespace&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/controller-publish-secret-name&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/controller-publish-secret-namespace&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/node-stage-secret-name&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/node-stage-secret-namespace&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/node-publish-secret-name&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/node-publish-secret-namespace&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/fstype&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;persistentvolumeclaim-and-persistentvolume-参数&quot;&gt;PersistentVolumeClaim and PersistentVolume 参数&lt;/h4&gt;

&lt;p&gt;CSI external-provisioner (v1.6.0+) 引入了 –extra-create-metadata 标志，它会在 CSI CreateVolumeRequest 中自动设置以下的parameters(map&amp;lt;string, string&amp;gt;)：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;csi.storage.k8s.io/pvc/name&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/pvc/namespace&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/pv/name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些参数不是 StorageClass 的一部分，而是使用源 PersistentVolumeClaim 和 PersistentVolume 的名称和命名空间在内部生成的。&lt;/p&gt;

&lt;h4 id=&quot;使用&quot;&gt;&lt;a href=&quot;https://github.com/kubernetes-csi/external-provisioner/blob/master/README.md&quot;&gt;使用&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;支持动态卷Provision的 CSI driver应该使用这个 sidecar 容器，并向外告知CSI CREATE_DELETE_VOLUME的控制器功能被支持。&lt;/p&gt;

&lt;p&gt;external-provisioner 可以与其他外部 CSI 控制器（例如 external-attacher、external-snapshotter 和/或 external-resizer）在同一个 pod 中运行。请注意，external-provisioner 不会随着更多副本进行扩展。只有一个外部供应者被选为leader并运行。其replica等待leader 失效。他们在leader失效后约 15 秒内重新选举新的active leader。&lt;/p&gt;

&lt;h3 id=&quot;external-resizer&quot;&gt;external-resizer&lt;/h3&gt;

&lt;p&gt;CSI external-resizer负责Watch PersistentVolumeClaim对象的更改，如果用户需要更多的Storage，则会调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerExpandVolume&lt;/code&gt;接口。&lt;/p&gt;
&lt;h4 id=&quot;使用-1&quot;&gt;使用&lt;/h4&gt;

&lt;p&gt;支持Kubernetes volume expansion的 CSI driver应该使用这个 sidecar 容器，并向外告知CSI VolumeExpansion的控制器功能被支持。&lt;/p&gt;

&lt;h3 id=&quot;external-attacher&quot;&gt;external-attacher&lt;/h3&gt;

&lt;p&gt;CSI external-attacher负责Watch VolumeAttachment对象并调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Controller[Publish|Unpublish]Volume&lt;/code&gt;接口。&lt;/p&gt;

&lt;h4 id=&quot;使用-2&quot;&gt;&lt;a href=&quot;https://github.com/kubernetes-csi/external-attacher/blob/master/README.md&quot;&gt;使用&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;支持Kubernetes volume attach/detach的 CSI driver应该使用这个 sidecar 容器，并向外告知CSI PUBLISH_UNPUBLISH_VOLUME的控制器功能被支持。&lt;/p&gt;

&lt;h3 id=&quot;node-driver-registrar&quot;&gt;node-driver-registrar&lt;/h3&gt;
&lt;p&gt;CSI node-driver-registrar通过调用CSI driver的NodeGetInfo接口获取信息，并使用Kubelet&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/pluginmanager/pluginwatcher/README.md&quot;&gt;插件注册&lt;/a&gt;机制向该node上的Kubelet组册CSI driver。&lt;/p&gt;

&lt;h4 id=&quot;使用-3&quot;&gt;使用&lt;/h4&gt;

&lt;p&gt;Kubelet 直接针对 CSI driver发起 CSI NodeGetInfo、NodeStageVolume 和 NodePublishVolume 调用。它使用 kubelet 插件注册机制来发现 Unix Domain Socket以与 CSI driver对话。因此，所有 CSI driver都应该使用这个 sidecar 容器向 kubelet 注册自己。&lt;/p&gt;

&lt;h3 id=&quot;external-snapshotter&quot;&gt;external-snapshotter&lt;/h3&gt;

&lt;p&gt;从Beta版本开始，snapshot controller会Watch Kubernetes Apiserver中的VolumeSnapshot和VolumeSnapshotContent CRD对象。CSI external-snapshotter sidecar仅Watch Kubernetes Apiserver的VolumeSnapshotContent CRD对象。CSI external-snapshotter sidecar还负责调用三个CreateSnapshot、DeleteSnapshot和ListSnapshots RPC接口。&lt;/p&gt;

&lt;h4 id=&quot;volumesnapshotclass-parameters&quot;&gt;VolumeSnapshotClass Parameters&lt;/h4&gt;

&lt;p&gt;配置新卷快照时，CSI external-snapshotter将CSI CreateSnapshotRequest调用中的parameters（map&amp;lt;string, string&amp;gt;）字段段设置为它正在处理的 VolumeSnapshotClass 中指定的键/值。&lt;/p&gt;

&lt;p&gt;CSI external-snapshotter还保留以csi.storage.k8s.io/为前缀的参数键。任何以csi.storage.k8s.io/为前缀的VolumeSnapshotClass键都不会作为parameters传递给 CSI Driver。&lt;/p&gt;

&lt;p&gt;以下保留的 VolumeSnapshotClass 参数键触发CSI external-snapshotter中的行为：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;csi.storage.k8s.io/snapshotter-secret-name (v1.0.1+)&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/snapshotter-secret-namespace (v1.0.1+)&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/snapshotter-list-secret-name (v2.1.0+)&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/snapshotter-list-secret-namespace (v2.1.0+)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有关如何处理secrets的更多信息，请参阅&lt;a href=&quot;https://kubernetes-csi.github.io/docs/secrets-and-credentials.html&quot;&gt;Secrets &amp;amp; Credentials&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;volumesnapshot-and-volumesnapshotcontent-parameters&quot;&gt;VolumeSnapshot and VolumeSnapshotContent Parameters&lt;/h4&gt;

&lt;p&gt;CSI external-snapshotter (v4.0.0+)引入了–extra-create-metadata标志，它会在CSI CreateSnapshotRequest调用中自动设置以下 parameters(map&amp;lt;string, string&amp;gt;)：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;csi.storage.k8s.io/volumesnapshot/name&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/volumesnapshot/namespace&lt;/li&gt;
  &lt;li&gt;csi.storage.k8s.io/volumesnapshotcontent/name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些parameters是使用Source VolumeSnapshot和VolumeSnapshotContent的name和namespace在内部生成的。&lt;/p&gt;

&lt;h4 id=&quot;使用-4&quot;&gt;使用&lt;/h4&gt;
&lt;p&gt;支持配置volume snapshots和使用这些snapshots配置新卷的能力的 CSI Driver应该使用这个 sidecar 容器，并通告 CSI CREATE_DELETE_SNAPSHOT controller功能。&lt;/p&gt;

&lt;p&gt;CSI external-snapshotter被部署为sidecar controller。&lt;/p&gt;

&lt;h3 id=&quot;livenessprobe&quot;&gt;livenessprobe&lt;/h3&gt;

&lt;p&gt;CSI livenessprobe 是一个 sidecar 容器，它监控 CSI driver 的健康状况，并通过 Liveness Probe 机制将其报告给 Kubernetes。这使 Kubernetes 能够自动检测Driver的问题并重新启动 pod 以尝试修复问题。&lt;/p&gt;

&lt;p&gt;liveness probe 是一个 sidecar 容器，它暴露了一个 HTTP /healthz 端点，它作为 kubelet 的 livenessProbe 钩子来监控 CSI Driver的健康状况。&lt;/p&gt;

&lt;p&gt;活性探针使用 Probe() 调用来检查 CSI Driver是否健康。有关 Probe API 调用的更多信息，请参阅 CSI 规范。容器存储接口 (CSI)&lt;/p&gt;

&lt;h3 id=&quot;external-health-monitor-controller&quot;&gt;external-health-monitor-controller&lt;/h3&gt;
&lt;p&gt;CSI external-health-monitor-controller 是一个 sidecar 容器，与 CSI 控制器Driver一起部署，类似于 CSI external-provisioner sidecar 的部署方式。它调用 CSI 控制器 RPC ListVolumes 或 ControllerGetVolume 来检查 CSI 卷的健康状况，如果卷的状况异常，则在 PersistentVolumeClaim 上报告事件。&lt;/p&gt;

&lt;p&gt;CSI external-health-monitor-controller 还监视节点故障事件。可以通过将 enable-node-watcher 标志设置为 true 来启用此组件。这现在只会对本地 PV 产生影响。当检测到节点故障事件时，会在 PVC 上报告一个事件，表明使用该 PVC 的 Pod 位于故障节点上。&lt;/p&gt;

&lt;h4 id=&quot;使用-5&quot;&gt;使用&lt;/h4&gt;

&lt;p&gt;支持 VOLUME_CONDITION 和 LIST_VOLUMES 或 VOLUME_CONDITION 和 GET_VOLUME 控制器功能的 CSI Driver应该使用这个 sidecar 容器。&lt;/p&gt;

&lt;h2 id=&quot;csi-object&quot;&gt;CSI Object&lt;/h2&gt;

&lt;h3 id=&quot;csidriver-object&quot;&gt;CSIDriver Object&lt;/h3&gt;
&lt;p&gt;CSIDriver Object有两个用途：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;简化Driver的发现
 如果 CSI Driver创建了一个 CSIDriver 对象，Kubernetes 用户可以很容易地发现安装在他们集群上的 CSI Driver（只需发出 kubectl get CSIDriver）&lt;/li&gt;
  &lt;li&gt;自定义 Kubernetes 行为
 Kubernetes 在处理 CSI Driver时有一组默认行为（例如，它默认调用 Attach/Detach 操作）。此对象允许 CSI Driver指定 Kubernetes 应如何与其交互。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CSI Driver Object主要包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;name: CSI Driver 的名字&lt;/li&gt;
  &lt;li&gt;attachRequired
    &lt;ul&gt;
      &lt;li&gt;指示此 CSI volume driver需要attach操作（因为它实现了 CSI ControllerPublishVolume 方法），并且 Kubernetes 应调用附加并等待任何attach操作完成，然后再继续挂载。&lt;/li&gt;
      &lt;li&gt;如果给定的 CSI driver不存在 CSIDriver 对象，则默认值为 true - 意味着将调用附加。&lt;/li&gt;
      &lt;li&gt;如果给定的 CSI driver存在 CSIDriver 对象，但未指定此字段，则它也默认为 true - 意味着将调用附加。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;podInfoOnMount
    &lt;ul&gt;
      &lt;li&gt;表示此 CSI Driver在挂载操作期间需要额外的 pod 信息（如 pod 名称、pod UID 等）。&lt;/li&gt;
      &lt;li&gt;如果 value 未指定或为 false，则不会在 mount 时传递 pod 信息。&lt;/li&gt;
      &lt;li&gt;如果 value 设置为 true，Kubelet 将在 CSI NodePublishVolume 调用中将 pod 信息作为 volume_context 传递：
        &lt;ul&gt;
          &lt;li&gt;“csi.storage.k8s.io/pod.name”：pod.Name&lt;/li&gt;
          &lt;li&gt;“csi.storage.k8s.io/pod.namespace”：pod.Namespace&lt;/li&gt;
          &lt;li&gt;“csi.storage.k8s.io/pod.uid”：字符串（pod.UID）&lt;/li&gt;
          &lt;li&gt;“csi.storage.k8s.io/serviceAccount.name”：pod.Spec.ServiceAccountName&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;fsGroupPolicy
    &lt;ul&gt;
      &lt;li&gt;此字段是在 Kubernetes 1.19 中添加的，在使用较旧的 Kubernetes 版本时无法设置。&lt;/li&gt;
      &lt;li&gt;该字段在 Kubernetes 1.20 中为 beta，在 Kubernetes 1.23 中为 GA。&lt;/li&gt;
      &lt;li&gt;控制此 CSI 卷Driver是否在安装卷时支持卷所有权和权限更改。&lt;/li&gt;
      &lt;li&gt;支持以下模式，如果未指定，则默认为 ReadWriteOnceWithFSType：
        &lt;ul&gt;
          &lt;li&gt;无：表示卷将在没有修改的情况下挂载，因为 CSI 卷Driver不支持这些操作。&lt;/li&gt;
          &lt;li&gt;File：表示 CSI 卷驱动支持通过 fsGroup 更改卷所有权和权限，Kubernetes 可以使用 fsGroup 更改卷的权限和所有权，以匹配 pod 的 SecurityPolicy 中用户请求的 fsGroup，而不管 fstype 或访问模式如何。&lt;/li&gt;
          &lt;li&gt;ReadWriteOnceWithFSType：表示将检查卷以确定是否应修改卷所有权和权限以匹配 pod 的安全策略。仅当定义了 fsType 并且持久卷的 accessModes 包含 ReadWriteOnce 时才会发生更改。如果没有定义其他 FSGroupPolicy，这是默认行为。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;volumeLifecycleModes
    &lt;ul&gt;
      &lt;li&gt;此字段是在 Kubernetes 1.16 中添加的，并且在使用较旧的 Kubernetes 版本时无法设置。&lt;/li&gt;
      &lt;li&gt;该字段为测试版。&lt;/li&gt;
      &lt;li&gt;它通知 Kubernetes Driver支持的卷模式。这样可以确保Driver不会被用户错误地使用。默认为 Persistent，这是正常的 PVC/PV 机制。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;tokenRequests
    &lt;ul&gt;
      &lt;li&gt;该字段是在 Kubernetes 1.20 中添加的，在使用较旧的 Kubernetes 版本时无法设置。&lt;/li&gt;
      &lt;li&gt;该字段在 Kubernetes 1.21 中默认启用，自 1.22 起无法禁用。&lt;/li&gt;
      &lt;li&gt;如果指定了该字段，Kubelet 将在 NodePublishVolume 中将绑定pod的服务帐户令牌作为 volume_context
        &lt;ul&gt;
          &lt;li&gt;“csi.storage.k8s.io/serviceAccount.tokens”: {“gcp”:{“token”:”&lt;token&gt;&quot;,&quot;expirationTimestamp&quot;:&quot;&lt;RFC3339 中的过期时间戳=&quot;&quot;&gt;&quot;}}&lt;/RFC3339&gt;&lt;/token&gt;&lt;/li&gt;
          &lt;li&gt;如果 CSI Driver没有找到 volume_context 中记录的令牌，它应该在 NodePublishVolume 中返回错误以通知 Kubelet 重试。&lt;/li&gt;
          &lt;li&gt;Audiences应该是不同的，否则验证将失败。如果Audiences为“”，则表示发行的令牌与 kube-apiserver 具有相同的Audiences。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;requiresRepublish
    &lt;ul&gt;
      &lt;li&gt;该字段是在 Kubernetes 1.20 中添加的，在使用较旧的 Kubernetes 版本时无法设置。&lt;/li&gt;
      &lt;li&gt;该字段在 Kubernetes 1.21 中默认启用，自 1.22 起无法禁用。&lt;/li&gt;
      &lt;li&gt;如果该字段为真，Kubelet 会定期调用 NodePublishVolume。这在以下情况下很有用：
        &lt;ul&gt;
          &lt;li&gt;如果 CSI Driver挂载的卷是短暂的。&lt;/li&gt;
          &lt;li&gt;如果 CSI Driver重复需要有效的服务帐户令牌（由字段 tokenRequests 启用）。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CSI Driver应该只自动更新卷的内容。正在运行的容器不会看到挂载点更改。
```
apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
name: mycsidriver.example.com
spec:
attachRequired: true
podInfoOnMount: true
fsGroupPolicy: File # added in Kubernetes 1.19, this field is GA as of Kubernetes 1.23
volumeLifecycleModes: # added in Kubernetes 1.16, this field is beta
        &lt;ul&gt;
          &lt;li&gt;Persistent&lt;/li&gt;
          &lt;li&gt;Ephemeral
tokenRequests: # added in Kubernetes 1.20. See status at https://kubernetes-csi.github.io/docs/token-requests.html#status&lt;/li&gt;
          &lt;li&gt;audience: “gcp”&lt;/li&gt;
          &lt;li&gt;audience: “” # empty string means defaulting to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--api-audiences&lt;/code&gt; of kube-apiserver
expirationSeconds: 3600
requiresRepublish: true # added in Kubernetes 1.20. See status at https://kubernetes-csi.github.io/docs/token-requests.html#status
```&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要安装，CSI Driver的部署清单必须包含一个 CSIDriver 对象，如上例所示。&lt;/p&gt;

&lt;p&gt;CSIDriver 实例应该存在于所有使用相应 CSI Driver提供的卷的 Pod 的整个生命周期中，因此 Skip Attach 和 Pod Info on Mount 功能可以正常工作。&lt;/p&gt;

&lt;h3 id=&quot;csinode-object&quot;&gt;CSINode Object&lt;/h3&gt;

&lt;p&gt;CSI Driver会生成节点特定信息。但是这些信息不是存储在 Kubernetes Node API 对象中，而是创建了一个新的 CSI 特定的 Kubernetes CSINode 对象。它有以下用途：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将 Kubernetes 节点名称映射到 CSI 节点名称，
    &lt;ul&gt;
      &lt;li&gt;CSI GetNodeInfo 接口会返回存储系统引用的节点名称。Kubernetes 必须在以后的 ControllerPublishVolume 调用中使用此名称。因此，当注册新的 CSI Driver时，Kubernetes 会将存储系统的Node ID 存储在 CSINode 对象中以供将来使用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CSI Driver是否可用
    &lt;ul&gt;
      &lt;li&gt;一种kubelet 通知 kube-controller-manager 和 kubernetes scheduler CSI Driver在节点上是否可用（已注册）的方法。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Volume topology
    &lt;ul&gt;
      &lt;li&gt;CSI GetNodeInfo 接口会返回一组标识该节点拓扑结构的键/值标签。 Kubernetes 使用此信息进行拓扑感知配置。它将键/值作为标签存储在 Kubernetes Node对象上。为了记录哪些 Node 标签属于特定的 CSI Driver，kubelet 将这些键存储在 CSINode 对象中以供将来参考。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CSINode Object主要包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;drivers: 在节点上运行的 CSI Driver列表及其属性。&lt;/li&gt;
  &lt;li&gt;name: 此对象引用的 CSI Driver。&lt;/li&gt;
  &lt;li&gt;nodeID: 由Driver确定的NodeId&lt;/li&gt;
  &lt;li&gt;topologyKeys: Driver支持的分配给节点的拓扑键列表。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: storage.k8s.io/v1
kind: CSINode
metadata:
  name: node1
spec:
  drivers:
  - name: mycsidriver.example.com
    nodeID: storageNodeID1
    topologyKeys: [&apos;mycsidriver.example.com/regions&apos;, &quot;mycsidriver.example.com/zones&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CSI Driver不需要直接创建CSINode对象。当 CSI Driver通过 kubelet 插件注册机制注册时，kubelet会管理该对象。node-driver-registrar sidecar 容器有助于此注册。&lt;/p&gt;

&lt;h2 id=&quot;deployment-in-kubernetes&quot;&gt;Deployment in Kubernetes&lt;/h2&gt;

&lt;p&gt;CSI Driver通常作为两个组件部署在 Kubernetes 中：controller和每个节点上的组件。&lt;/p&gt;

&lt;h3 id=&quot;controller-plugin&quot;&gt;Controller Plugin&lt;/h3&gt;

&lt;p&gt;Controller Plugin可以作为 Deployment 或 StatefulSet 部署在集群中的任何节点上。 它由实现 CSI Controller 服务的 CSI Driver和一个或多个 sidecar 容器组成。 这些控制器sidecar容器通常与 Kubernetes 对象交互并调用Driver的 CSI 接口。&lt;/p&gt;

&lt;p&gt;它通常不需要直接访问宿主机，通过 Kubernetes API 和external control plane服务执行其所有操作。 可以为 HA 部署多个副本，但是建议使用leader election来确保一次只有一个活动Controller。&lt;/p&gt;

&lt;p&gt;控制器 sidecar 包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;external-provisioner&lt;/li&gt;
  &lt;li&gt;external-attacher&lt;/li&gt;
  &lt;li&gt;external-snapshotter&lt;/li&gt;
  &lt;li&gt;external-resizer。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在部署中包含 sidecar 是可选的。Sidecar 容器管理 Kubernetes event并对 CSI driver进行适当的调用。 调用是通过 sidecar 和 CSI Driver之间的 emptyDir 卷共享 Unix Domain Socket来进行的。&lt;/p&gt;

&lt;h3 id=&quot;node-plugin&quot;&gt;Node Plugin&lt;/h3&gt;

&lt;p&gt;Node Plugin应该通过 DaemonSet 部署在集群中的每个节点上。 它由实现 CSI Node Service的 CSI Driver和node-driver-registrar sidecar容器组成。&lt;/p&gt;

&lt;p&gt;Node上运行的Kubelet会调用 CSI Node Service，从存储系统中挂载和卸载存储卷，使其可供 Pod 使用。 Kubelet通过使用Host上的HostPath Volume共享的UNIX domain socket 调用 CSI Driver。 此外还有另一个UNIX domain socket，node-driver-registrar 使用它来将 CSI Driver注册到 Kubelet。&lt;/p&gt;

&lt;h4 id=&quot;driver-volume-mounts&quot;&gt;Driver Volume Mounts&lt;/h4&gt;
&lt;p&gt;节点插件需要直接访问主机以使块设备和/或文件系统挂载可用于 Kubernetes kubelet。&lt;/p&gt;

&lt;p&gt;CSI Driver使用的挂载点必须设置为双向，以允许主机上的 Kubelet 看到由 CSI Driver容器创建的挂载。 请参见下面的示例：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      containers:
      - name: my-csi-driver
        ...
        volumeMounts:
        - name: socket-dir
          mountPath: /csi
        - name: mountpoint-dir
          mountPath: /var/lib/kubelet/pods
          mountPropagation: &quot;Bidirectional&quot;
      - name: node-driver-registrar
        ...
        volumeMounts:
        - name: registration-dir
          mountPath: /registration
      volumes:
      # This volume is where the socket for kubelet-&amp;gt;driver communication is done
      - name: socket-dir
        hostPath:
          path: /var/lib/kubelet/plugins/&amp;lt;driver-name&amp;gt;
          type: DirectoryOrCreate
      # This volume is where the driver mounts volumes
      - name: mountpoint-dir
        hostPath:
          path: /var/lib/kubelet/pods
          type: Directory
      # This volume is where the node-driver-registrar registers the plugin
      # with kubelet
      - name: registration-dir
        hostPath:
          path: /var/lib/kubelet/plugins_registry
          type: Directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Johan Wang</name><email>youhangwang@foxmail.com</email></author><category term="ContainerStorage" /><category term="Kubernetes" /><category term="CSI" /><summary type="html">CSI是一套通用的RPC接口，可以将Block和File System暴露给Kubernetes等容器编排系统(CO)上运行的容器化工作负载。通过使用CSI，第三方存储提供商可以编写和部署插件，在Kubernetes中公开新的存储系统，而无需接触Kubernetes的核心代码。</summary></entry><entry><title type="html">gRPC简介</title><link href="http://localhost:4000/2022/01/11/grpc.html" rel="alternate" type="text/html" title="gRPC简介" /><published>2022-01-11T00:00:00+08:00</published><updated>2022-01-11T00:00:00+08:00</updated><id>http://localhost:4000/2022/01/11/grpc</id><content type="html" xml:base="http://localhost:4000/2022/01/11/grpc.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://grpc.io/docs/what-is-grpc/faq/&quot;&gt;官方文档&lt;/a&gt;中给出的定义是：gRPC是一个现代化的，开源的，能够在任意地方运行的远程服务调用框架，它可以使服务端和客户端的应用进行透明的通信，可以很方便的构建相互关联的系统。gRPC是gRPC Remote Procedure Calls的缩写。&lt;/p&gt;

&lt;p&gt;在gRPC框架中，客户端应用程序可以像调用本地对象的方法一样直接调用不同机器上的服务端应用程序的方法。gRPC基于定义服务的思想，指定可以被远程调用的方法及其参数和返回类型。在服务端实现这个接口并运行一个gRPC server来处理客户端调用。客户端有一个Stub（在某些语言中称为client），它提供与服务端相同的方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../assets/images/posts/landing.png&quot; alt=&quot;gRPC&quot; class=&quot;rounded&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;为什么grpc比其他基于http2的binary-blob更好&quot;&gt;为什么gRPC比其他基于HTTP/2的binary blob更好？&lt;/h3&gt;
&lt;p&gt;gRPC也是一组library，可以提供一些更高级别的，跨平台一致的功能，而这些功能通用HTTP库通常不会提供。此类功能的示例包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在应用层的流量控制&lt;/li&gt;
  &lt;li&gt;级联调用取消&lt;/li&gt;
  &lt;li&gt;负载平衡和故障转移&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;为什么-grpc-比-rest-更好&quot;&gt;为什么 gRPC 比 REST 更好？&lt;/h3&gt;
&lt;p&gt;gRPC在很大程度上遵循HTTP/2之上的HTTP语义，但gPRC明确的允许全双工流式传输。与典型的REST不同之处在于：在调用调度期间出于性能的考虑使用的是静态路径，因为从路径、查询参数和有效负载的正文中解析调用参数会增加延迟和复杂性。gRPC还形式化了一组错误，这些错误比HTTP状态代码更直接适用于API用例。&lt;/p&gt;

&lt;h2 id=&quot;protocol-buffers&quot;&gt;Protocol Buffers&lt;/h2&gt;

&lt;p&gt;默认情况下，gRPC使用Protocol Buffers，这是Google用于序列化结构化数据的成熟开源机制（尽管gRPC可以与JSON等其他数据格式一起使用）。&lt;/p&gt;

&lt;p&gt;使用Protocol Buffer的第一步是在proto文件中定义需要序列化的数据结构：这是一个带有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.proto&lt;/code&gt;扩展名的普通文本文件。Protocol Buffers数据被结构化为消息，其中每条消息都是一个小的信息逻辑记录，包含一系列称为字段的Key-Value对：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message Person {
  string name = 1;
  int32 id = 2;
  bool has_ponycopter = 3;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一旦指定了数据结构，就可以使用Protocol Buffers编译器&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;protoc&lt;/code&gt;生成目标语言的数据访问类。它为每个字段提供了简单的访问器，如name()和set_name()，以及将整个结构序列化成raw data和解析raw data的方法。如果目标语言是Golang，则在上面的示例中运行编译器将生成一个名为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Person&lt;/code&gt;的结构体。然后可以在应用程序中使用它来填充、序列化和检索Person的Protocol Buffer消息。&lt;/p&gt;

&lt;p&gt;要了解有关Protocol Buffer的更多信息，包括如何使用目标语言的gRPC插件安装protoc，请参阅Protocol Buffer&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/overview&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;architecture&quot;&gt;Architecture&lt;/h2&gt;

&lt;p&gt;gRPC是基于服务定义的思想：指定服务中可以被调用的方法和方法中的参数和返回类型。例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;gRPC中可以定义四种类型的服务方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Unary RPCs&lt;/li&gt;
  &lt;li&gt;Server Streaming RPCs&lt;/li&gt;
  &lt;li&gt;Client Streaming RPCs&lt;/li&gt;
  &lt;li&gt;Bidirectional Streaming RPCs&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unary-rpcs&quot;&gt;Unary RPCs&lt;/h3&gt;
&lt;p&gt;同正常的函数调用一样，客户端发送一次请求，服务端返回一次结果。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc SayHello(HelloRequest) returns (HelloResponse);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;一旦客户端调用了一个stub方法，gRPC Server就会被通知该RPC已被调用，其中包含发起调用的客户端元数据，方法名称和指定的Deadline。&lt;/li&gt;
  &lt;li&gt;然后，服务端可以立即发回自己的初始元数据（必须在发送任何响应之前发送），或者等待客户端的请求消息。具体哪个先发生取决于特定的应用程序。&lt;/li&gt;
  &lt;li&gt;一旦服务端收到客户端的请求消息，它就会执行必要的工作来创建和填充响应。然后将响应连同状态详细信息（状态代码和可选的状态消息）和可选尾随元数据一起返回（如果成功）给客户端。&lt;/li&gt;
  &lt;li&gt;如果响应状态为 OK，则客户端得到响应，从而完成客户端的调用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;server-streaming-rpcs&quot;&gt;Server streaming RPCs&lt;/h3&gt;
&lt;p&gt;Server streaming RPC类似于Unary RPC：但是服务端会返回一个Stream，通过Stream发送所有消息后，服务端的状态详细信息（状态代码和可选状态消息）和可选的尾随元数据将发送到客户端，这样就完成了服务端的处理。客户端可以从Stream中不断地读取消息直到全部消息读取完毕。gRPC会保证每一个RPC调用中的消息顺序。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;client-streaming-rpcs&quot;&gt;Client streaming RPCs&lt;/h3&gt;
&lt;p&gt;Client streaming RPC类似于Unary RPC：不同之处在于客户端向服务端发送消息流而不是单个消息。通常但不一定是在它收到所有客户端的消息之后，服务端响应一条消息（连同其状态详细信息和可选的尾随元数据）。gRPC会保证每一个RPC调用中的消息顺序。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;bidirectional-streaming-rpcs&quot;&gt;Bidirectional streaming RPCs&lt;/h3&gt;
&lt;p&gt;在Bidirectional streaming RPC中，客户端发起调用，服务端接收客户端的元数据、方法名称和截止日期。服务端可以选择发回其初始元数据或等待客户端开始流式传输消息。客户端和服务端的流处理是特定于应用程序的。由于这两个流是独立的，客户端和服务端可以以任意顺序读写消息。例如，服务端可以等到它收到客户端的所有消息后再写入它的消息，或者服务端和客户端可以ping-pong——服务端收到请求，然后发回响应，然后客户端发送基于响应的另一个请求，依此类推。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;deadlinestimeouts&quot;&gt;Deadlines/Timeouts&lt;/h3&gt;
&lt;p&gt;gRPC客户端可以指定在RPC发生DEADLINE_EXCEEDED错误被终止之前，能够等待RPC完成的时间。在服务端，可以查询特定的RPC是否已超时，或者还剩多少时间来完成RPC。&lt;/p&gt;

&lt;p&gt;指定期限或超时是特定于语言的：一些语言API根据超时（时间的长短）工作，而一些语言API根据期限（固定时间点）工作，可能有也可能没有默认期限。&lt;/p&gt;

&lt;h3 id=&quot;rpc-termination&quot;&gt;RPC termination&lt;/h3&gt;

&lt;p&gt;在gRPC中，客户端和服务端都对调用是否成功做出独立的本地判断，它们的结论可能不匹配。这意味着可能有一个RPC在服务端成功完成（“我已发送所有响应！”）但在客户端失败（“响应在我的截止日期之后到达！”）。服务端也可以在客户端发送所有请求之前决定完成。&lt;/p&gt;

&lt;h3 id=&quot;cancelling-an-rpc&quot;&gt;Cancelling an RPC&lt;/h3&gt;
&lt;p&gt;客户端或服务端都可以随时取消RPC。取消会立即终止RPC，以便不再进行任何工作。&lt;/p&gt;

&lt;h3 id=&quot;metadata&quot;&gt;Metadata&lt;/h3&gt;
&lt;p&gt;元数据是关于特定RPC调用的信息（例如身份验证详细信息），采用键值对列表的形式，其中键是字符串，值通常是字符串，但也可以是二进制数据。元数据对 gRPC 本身是不透明的——它允许客户端提供与服务端调用相关的信息，反之亦然。&lt;/p&gt;

&lt;p&gt;对元数据的访问取决于语言。&lt;/p&gt;

&lt;h3 id=&quot;channels&quot;&gt;Channels&lt;/h3&gt;

&lt;p&gt;gRPC Channel提供与指定 Host 和 Port上的 gRPC server的连接。它在创建客户端stub时使用。客户端可以指定Channel参数来修改 gRPC 的默认行为，例如打开或关闭消息压缩。Channel具有状态，包括已连接和空闲。&lt;/p&gt;

&lt;p&gt;gRPC 如何处理关闭Channel取决于语言。一些语言还允许查询Channel状态。&lt;/p&gt;</content><author><name>Johan Wang</name><email>youhangwang@foxmail.com</email></author><category term="gRPC" /><summary type="html">Overview 官方文档中给出的定义是：gRPC是一个现代化的，开源的，能够在任意地方运行的远程服务调用框架，它可以使服务端和客户端的应用进行透明的通信，可以很方便的构建相互关联的系统。gRPC是gRPC Remote Procedure Calls的缩写。 在gRPC框架中，客户端应用程序可以像调用本地对象的方法一样直接调用不同机器上的服务端应用程序的方法。gRPC基于定义服务的思想，指定可以被远程调用的方法及其参数和返回类型。在服务端实现这个接口并运行一个gRPC server来处理客户端调用。客户端有一个Stub（在某些语言中称为client），它提供与服务端相同的方法。 为什么gRPC比其他基于HTTP/2的binary blob更好？ gRPC也是一组library，可以提供一些更高级别的，跨平台一致的功能，而这些功能通用HTTP库通常不会提供。此类功能的示例包括： 在应用层的流量控制 级联调用取消 负载平衡和故障转移 为什么 gRPC 比 REST 更好？ gRPC在很大程度上遵循HTTP/2之上的HTTP语义，但gPRC明确的允许全双工流式传输。与典型的REST不同之处在于：在调用调度期间出于性能的考虑使用的是静态路径，因为从路径、查询参数和有效负载的正文中解析调用参数会增加延迟和复杂性。gRPC还形式化了一组错误，这些错误比HTTP状态代码更直接适用于API用例。 Protocol Buffers 默认情况下，gRPC使用Protocol Buffers，这是Google用于序列化结构化数据的成熟开源机制（尽管gRPC可以与JSON等其他数据格式一起使用）。 使用Protocol Buffer的第一步是在proto文件中定义需要序列化的数据结构：这是一个带有.proto扩展名的普通文本文件。Protocol Buffers数据被结构化为消息，其中每条消息都是一个小的信息逻辑记录，包含一系列称为字段的Key-Value对： message Person { string name = 1; int32 id = 2; bool has_ponycopter = 3; } 一旦指定了数据结构，就可以使用Protocol Buffers编译器protoc生成目标语言的数据访问类。它为每个字段提供了简单的访问器，如name()和set_name()，以及将整个结构序列化成raw data和解析raw data的方法。如果目标语言是Golang，则在上面的示例中运行编译器将生成一个名为Person的结构体。然后可以在应用程序中使用它来填充、序列化和检索Person的Protocol Buffer消息。 要了解有关Protocol Buffer的更多信息，包括如何使用目标语言的gRPC插件安装protoc，请参阅Protocol Buffer文档 Architecture gRPC是基于服务定义的思想：指定服务中可以被调用的方法和方法中的参数和返回类型。例如： service HelloService { rpc SayHello (HelloRequest) returns (HelloResponse); } message HelloRequest { string greeting = 1; } message HelloResponse { string reply = 1; } gRPC中可以定义四种类型的服务方法： Unary RPCs Server Streaming RPCs Client Streaming RPCs Bidirectional Streaming RPCs Unary RPCs 同正常的函数调用一样，客户端发送一次请求，服务端返回一次结果。 rpc SayHello(HelloRequest) returns (HelloResponse); 一旦客户端调用了一个stub方法，gRPC Server就会被通知该RPC已被调用，其中包含发起调用的客户端元数据，方法名称和指定的Deadline。 然后，服务端可以立即发回自己的初始元数据（必须在发送任何响应之前发送），或者等待客户端的请求消息。具体哪个先发生取决于特定的应用程序。 一旦服务端收到客户端的请求消息，它就会执行必要的工作来创建和填充响应。然后将响应连同状态详细信息（状态代码和可选的状态消息）和可选尾随元数据一起返回（如果成功）给客户端。 如果响应状态为 OK，则客户端得到响应，从而完成客户端的调用。 Server streaming RPCs Server streaming RPC类似于Unary RPC：但是服务端会返回一个Stream，通过Stream发送所有消息后，服务端的状态详细信息（状态代码和可选状态消息）和可选的尾随元数据将发送到客户端，这样就完成了服务端的处理。客户端可以从Stream中不断地读取消息直到全部消息读取完毕。gRPC会保证每一个RPC调用中的消息顺序。 rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse); Client streaming RPCs Client streaming RPC类似于Unary RPC：不同之处在于客户端向服务端发送消息流而不是单个消息。通常但不一定是在它收到所有客户端的消息之后，服务端响应一条消息（连同其状态详细信息和可选的尾随元数据）。gRPC会保证每一个RPC调用中的消息顺序。 rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse); Bidirectional streaming RPCs 在Bidirectional streaming RPC中，客户端发起调用，服务端接收客户端的元数据、方法名称和截止日期。服务端可以选择发回其初始元数据或等待客户端开始流式传输消息。客户端和服务端的流处理是特定于应用程序的。由于这两个流是独立的，客户端和服务端可以以任意顺序读写消息。例如，服务端可以等到它收到客户端的所有消息后再写入它的消息，或者服务端和客户端可以ping-pong——服务端收到请求，然后发回响应，然后客户端发送基于响应的另一个请求，依此类推。 rpc BidiHello(stream HelloRequest) returns (stream HelloResponse); Deadlines/Timeouts gRPC客户端可以指定在RPC发生DEADLINE_EXCEEDED错误被终止之前，能够等待RPC完成的时间。在服务端，可以查询特定的RPC是否已超时，或者还剩多少时间来完成RPC。 指定期限或超时是特定于语言的：一些语言API根据超时（时间的长短）工作，而一些语言API根据期限（固定时间点）工作，可能有也可能没有默认期限。 RPC termination 在gRPC中，客户端和服务端都对调用是否成功做出独立的本地判断，它们的结论可能不匹配。这意味着可能有一个RPC在服务端成功完成（“我已发送所有响应！”）但在客户端失败（“响应在我的截止日期之后到达！”）。服务端也可以在客户端发送所有请求之前决定完成。 Cancelling an RPC 客户端或服务端都可以随时取消RPC。取消会立即终止RPC，以便不再进行任何工作。 Metadata 元数据是关于特定RPC调用的信息（例如身份验证详细信息），采用键值对列表的形式，其中键是字符串，值通常是字符串，但也可以是二进制数据。元数据对 gRPC 本身是不透明的——它允许客户端提供与服务端调用相关的信息，反之亦然。 对元数据的访问取决于语言。 Channels gRPC Channel提供与指定 Host 和 Port上的 gRPC server的连接。它在创建客户端stub时使用。客户端可以指定Channel参数来修改 gRPC 的默认行为，例如打开或关闭消息压缩。Channel具有状态，包括已连接和空闲。 gRPC 如何处理关闭Channel取决于语言。一些语言还允许查询Channel状态。</summary></entry><entry><title type="html">Kubelet Plugin Registration Service</title><link href="http://localhost:4000/2022/01/05/plugin-registration.html" rel="alternate" type="text/html" title="Kubelet Plugin Registration Service" /><published>2022-01-05T00:00:00+08:00</published><updated>2022-01-05T00:00:00+08:00</updated><id>http://localhost:4000/2022/01/05/plugin-registration</id><content type="html" xml:base="http://localhost:4000/2022/01/05/plugin-registration.html">&lt;p&gt;可扩展性是Kubernetes一直所遵循的设计哲学。Kubelet在实现上使用Plugin模式在无需修改核心代码的前提下实现功能扩展。&lt;!--more--&gt;目前Kubelet支持两种Plugin类型：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Device Plugin&lt;/li&gt;
  &lt;li&gt;CSI Plugin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了统一两种插件的注册方式，Kubelet使用一种通用的注册机制为两种Plugin提供注册服务，本文将会对其做详细的介绍。&lt;/p&gt;

&lt;h2 id=&quot;plugin-manger&quot;&gt;Plugin Manger&lt;/h2&gt;

&lt;p&gt;Kubelet通过使用Plugin Manger对Plugins做注册和注销操作：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Kubelet struct {
    ...
    // pluginmanager 运行一系列的异步循环检查哪些plugin需要注册或注销，并执行相应操作
    pluginManager pluginmanager.PluginManager
    ...
}
type PluginManager interface {
    // 运行 plugin manager及其管理的异步循环
    Run(sourcesReady config.SourcesReady, stopCh &amp;lt;-chan struct{})

    // AddHandler会为每种plugin类型（CSI，Device）添加处理函数。 
    AddHandler(pluginType string, pluginHandler cache.PluginHandler)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PluginManager&lt;/code&gt;是一个接口，它包含两个方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Run(sourcesReady config.SourcesReady, stopCh &amp;lt;-chan struct{}): 会启动一系列异步的循环不断的检查有哪些Plugin需要注册和注销&lt;/li&gt;
  &lt;li&gt;AddHandler(pluginType string, pluginHandler cache.PluginHandler)：为每一种plugin type添加处理函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pluginManger实例的创建：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;klet.pluginManager = pluginmanager.NewPluginManager(
    // 获取Plugin注册Socket的所在目录，通常为$ROOT_DIR + /plugins_registry
    klet.getPluginsRegistrationDir(), /* sockDir */
    kubeDeps.Recorder,
)

func NewPluginManager(
    sockDir string,
    recorder record.EventRecorder) PluginManager {
    asw := cache.NewActualStateOfWorld()
    dsw := cache.NewDesiredStateOfWorld()
    reconciler := reconciler.NewReconciler(
        operationexecutor.NewOperationExecutor(
            operationexecutor.NewOperationGenerator(
                recorder,
            ),
        ),
        loopSleepDuration,
        dsw,
        asw,
    )

    pm := &amp;amp;pluginManager{
        desiredStateOfWorldPopulator: pluginwatcher.NewWatcher(
            sockDir,
            dsw,
        ),
        reconciler:          reconciler,
        desiredStateOfWorld: dsw,
        actualStateOfWorld:  asw,
    }
    return pm
}

// pluginManager 实现了 PluginManager 接口
type pluginManager struct {
    // Watch sockDir中是否有新的socket，并异步地更新desiredStateOfWorld
    desiredStateOfWorldPopulator *pluginwatcher.Watcher

    // 周期性异步地通过operationExecutor调用注册和注销方法使actualStateOfWorld符合desiredStateOfWorld
    reconciler reconciler.Reconciler

    // 真实世界的状态，例如哪些plugin已经被注册，哪些plugin已经被注销。一旦Plugin被成功注册或者reconciler出发点了注销方法，会更新该数据结构。
    actualStateOfWorld cache.ActualStateOfWorld

    // 表示期望世界的状态，例如哪些plugin需要被注册，哪些plugin需要被注销。该数据结构被desiredStateOfWorldPopulator（Watcher）更新
    desiredStateOfWorld cache.DesiredStateOfWorld
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;pluginManager中主要包含以下内容：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;actualStateOfWorld：表示真实世界的状态，例如哪些plugin已经被注册，哪些plugin已经被注销。&lt;/li&gt;
  &lt;li&gt;desiredStateOfWorld：表示期望世界的状态，例如哪些plugin需要被注册，哪些plugin需要被注销。&lt;/li&gt;
  &lt;li&gt;reconciler：周期性异步的通过调用注册和注销方法使actualStateOfWorld符合desiredStateOfWorld。&lt;/li&gt;
  &lt;li&gt;desiredStateOfWorldPopulator：异步地watch sockDir中是否有新的socket，并更新desiredStateOfWorld。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;添加两种plugin type的处理函数，并运行pluginManager：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 添加CSI Driver的注册回调函数
kl.pluginManager.AddHandler(pluginwatcherapi.CSIPlugin, plugincache.PluginHandler(csi.PluginHandler))
// 添加Device Manager的注册回调函数
kl.pluginManager.AddHandler(pluginwatcherapi.DevicePlugin, kl.containerManager.GetPluginRegistrationHandler())
// 启动 plugin manager
go kl.pluginManager.Run(kl.sourcesReady, wait.NeverStop)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pluginwatcherapi.CSIPlugin&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pluginwatcherapi.DevicePlugin&lt;/code&gt;分别代表两种Plugin类型：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CSIPlugin&lt;/li&gt;
  &lt;li&gt;DevicePlugin&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CSIPlugin和DevicePlugin使用两种不同的处理函数：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#csi-plugin-handler&quot;&gt;plugincache.PluginHandler(csi.PluginHandler)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#containermanger-pluginregistrationhandler&quot;&gt;kl.containerManager.GetPluginRegistrationHandler()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pluginManager.AddHandler会将处理函数添加到reconciler的handlers中&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (pm *pluginManager) AddHandler(pluginType string, handler cache.PluginHandler) {
    pm.reconciler.AddHandler(pluginType, handler)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;pluginManager.Run 方法会启动desiredStateOfWorldPopulator，不断的更新desiredStateOfWorld。再使用协程启动reconciler：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (pm *pluginManager) Run(sourcesReady config.SourcesReady, stopCh &amp;lt;-chan struct{}) {
    defer runtime.HandleCrash()

    pm.desiredStateOfWorldPopulator.Start(stopCh)
    klog.V(2).InfoS(&quot;The desired_state_of_world populator (plugin watcher) starts&quot;)

    klog.InfoS(&quot;Starting Kubelet Plugin Manager&quot;)
    go pm.reconciler.Run(stopCh)

    metrics.Register(pm.actualStateOfWorld, pm.desiredStateOfWorld)
    &amp;lt;-stopCh
    klog.InfoS(&quot;Shutting down Kubelet Plugin Manager&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Plugin Manger整体的流程就是这样，接下来我们进入其内部的各个组件，一探究竟。&lt;/p&gt;

&lt;h3 id=&quot;desiredstateofworld&quot;&gt;DesiredStateOfWorld&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DesiredStateOfWorld&lt;/code&gt;是一个接口，为kubelet plugin manager期望状态的缓存定义了一套线程安全的操作：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// DesiredStateOfWorld为kubelet plugin manager的期望状态缓存定义了一套线程安全的操作
// 该缓存包含了一个以该Node上Socket file路径为Key，Plugin Information为Value的map
type DesiredStateOfWorld interface {
    // 如果Cache中不存在该Plugin（Socket Path），则添加。如果存在，则修改timestamp。如果socketPath为空，则报错
    AddOrUpdatePlugin(socketPath string) error

    // 从Cache中删除该Plugin（Socket Path）
    RemovePlugin(socketPath string)

    // 获取Cache中的Plugins
    GetPluginsToRegister() []PluginInfo

    // 检查Plugin是否在Cache中存在
    PluginExists(socketPath string) bool
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实现是一个并发安全的Map：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func NewDesiredStateOfWorld() DesiredStateOfWorld {
    return &amp;amp;desiredStateOfWorld{
        socketFileToInfo: make(map[string]PluginInfo),
    }
}

type desiredStateOfWorld struct {

    // socketFileToInfo 包含了需要被注册的Plugin
    socketFileToInfo map[string]PluginInfo
    sync.RWMutex
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实现的接口也很简单，这里就不做详细介绍了：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (dsw *desiredStateOfWorld) AddOrUpdatePlugin(socketPath string) error {
    dsw.Lock()
    defer dsw.Unlock()

    if socketPath == &quot;&quot; {
        return fmt.Errorf(&quot;socket path is empty&quot;)
    }
    if _, ok := dsw.socketFileToInfo[socketPath]; ok {
        klog.V(2).InfoS(&quot;Plugin exists in actual state cache, timestamp will be updated&quot;, &quot;path&quot;, socketPath)
    }

    // Update the PluginInfo object.
    // Note that we only update the timestamp in the desired state of world, not the actual state of world
    // because in the reconciler, we need to check if the plugin in the actual state of world is the same
    // version as the plugin in the desired state of world
    dsw.socketFileToInfo[socketPath] = PluginInfo{
        SocketPath: socketPath,
        Timestamp:  time.Now(),
    }
    return nil
}

func (dsw *desiredStateOfWorld) RemovePlugin(socketPath string) {
    dsw.Lock()
    defer dsw.Unlock()

    delete(dsw.socketFileToInfo, socketPath)
}

func (dsw *desiredStateOfWorld) GetPluginsToRegister() []PluginInfo {
    dsw.RLock()
    defer dsw.RUnlock()

    pluginsToRegister := []PluginInfo{}
    for _, pluginInfo := range dsw.socketFileToInfo {
        pluginsToRegister = append(pluginsToRegister, pluginInfo)
    }
    return pluginsToRegister
}

func (dsw *desiredStateOfWorld) PluginExists(socketPath string) bool {
    dsw.RLock()
    defer dsw.RUnlock()

    _, exists := dsw.socketFileToInfo[socketPath]
    return exists
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;actualstateofworld&quot;&gt;ActualStateOfWorld&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ActualStateOfWorld&lt;/code&gt;是一个接口，为kubelet plugin manager真实状态的缓存定义了一套线程安全的操作：：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ActualStateOfWorld为kubelet plugin manager的实际状态缓存定义了一套线程安全的操作
// 该缓存包含了一个以该Node上Socket file路径为Key，Plugin Information为Value的map
type ActualStateOfWorld interface {

    // GetRegisteredPlugins 获取在真实环境中已经被注册的Plugin列表
    GetRegisteredPlugins() []PluginInfo

    // 向Cache中添加Plugin info。与desiredStateOfWorld不同，此时无需更新timestamp,如果有更新，则在真实状态的缓存中会表现为删除+创建
    AddPlugin(pluginInfo PluginInfo) error

    // 从Cache中删除Plugin（Socket Path）
    RemovePlugin(socketPath string)

    // 检查Cache中使用具有相同timestamp和SocketPath的Plugin
    PluginExistsWithCorrectTimestamp(pluginInfo PluginInfo) bool
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ActualStateOfWorld和DesiredStateOfWorld的实现基本一样，也是一个并发安全的Map，这里就不做展开了，有兴趣的同学可以去看源码。&lt;/p&gt;
&lt;h3 id=&quot;desiredstateofworldpopulator&quot;&gt;DesiredStateOfWorldPopulator&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DesiredStateOfWorldPopulator&lt;/code&gt;实际上是一个watcher：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pm := &amp;amp;pluginManager{
    desiredStateOfWorldPopulator: pluginwatcher.NewWatcher(
        sockDir,
        dsw,
    ),
    ...
}
func NewWatcher(sockDir string, desiredStateOfWorld cache.DesiredStateOfWorld) *Watcher {
    return &amp;amp;Watcher{
        path:                sockDir,
        fs:                  &amp;amp;utilfs.DefaultFs{},
        desiredStateOfWorld: desiredStateOfWorld,
    }
}
type Watcher struct {
    path                string
    fs                  utilfs.Filesystem
    fsWatcher           *fsnotify.Watcher
    desiredStateOfWorld cache.DesiredStateOfWorld
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;它会在Start时：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;确认path是否存在，如果不存在，则新建Path。&lt;/li&gt;
  &lt;li&gt;创建fsWatcher，并将Path及子目录添加至watch列表中。如果已经有存在Plugin注册Socket则调用handleCreateEvent处理&lt;/li&gt;
  &lt;li&gt;发现有新建/删除的注册socket则调用handleCreateEvent或handleDeleteEvent。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 监听path上plugin socket的创建与删除
func (w *Watcher) Start(stopCh &amp;lt;-chan struct{}) error {
    // 如果Path不存在，则创建相应的目录
    if err := w.init(); err != nil {
        return err
    }

    // 创建Watcher
    fsWatcher, err := fsnotify.NewWatcher()
    if err != nil {
        return fmt.Errorf(&quot;failed to start plugin fsWatcher, err: %v&quot;, err)
    }
    w.fsWatcher = fsWatcher

    // 监听Path及其children路径，并处理已经存在的plugin Sockets
    if err := w.traversePluginDir(w.path); err != nil {
        klog.ErrorS(err, &quot;Failed to traverse plugin socket path&quot;, &quot;path&quot;, w.path)
    }

    //不断从fsWatcher.Events/sWatcher.Errors channel中获取消息并处理。
    go func(fsWatcher *fsnotify.Watcher) {
        for {
            select {
            case event := &amp;lt;-fsWatcher.Events:
                //TODO: Handle errors by taking corrective measures
                if event.Op&amp;amp;fsnotify.Create == fsnotify.Create {
                    err := w.handleCreateEvent(event)
                    if err != nil {
                        klog.ErrorS(err, &quot;Error when handling create event&quot;, &quot;event&quot;, event)
                    }
                } else if event.Op&amp;amp;fsnotify.Remove == fsnotify.Remove {
                    w.handleDeleteEvent(event)
                }
                continue
            case err := &amp;lt;-fsWatcher.Errors:
                if err != nil {
                    klog.ErrorS(err, &quot;FsWatcher received error&quot;)
                }
                continue
            case &amp;lt;-stopCh:
                w.fsWatcher.Close()
                return
            }
        }
    }(fsWatcher)

    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;handleDeleteEvent直接从desiredStateOfWorld移除plugin：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (w *Watcher) handleDeleteEvent(event fsnotify.Event) {
    klog.V(6).InfoS(&quot;Handling delete event&quot;, &quot;event&quot;, event)

    socketPath := event.Name
    klog.V(2).InfoS(&quot;Removing socket path from desired state cache&quot;, &quot;path&quot;, socketPath)
    w.desiredStateOfWorld.RemovePlugin(socketPath)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;handleCreateEvent则会:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;判断新建的是否为Socket，如果是才会加入到desiredStateOfWorld&lt;/li&gt;
  &lt;li&gt;如果新建的是dir，则加入到watcher列表中监听&lt;/li&gt;
  &lt;li&gt;如果是其他文件，则直接忽略
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (w *Watcher) handleCreateEvent(event fsnotify.Event) error {
  fi, err := os.Stat(event.Name)
  if err != nil {
      return fmt.Errorf(&quot;stat file %s failed: %v&quot;, event.Name, err)
  }

  if strings.HasPrefix(fi.Name(), &quot;.&quot;) {
      klog.V(5).InfoS(&quot;Ignoring file (starts with &apos;.&apos;)&quot;, &quot;path&quot;, fi.Name())
      return nil
  }

  if !fi.IsDir() {
      isSocket, err := util.IsUnixDomainSocket(util.NormalizePath(event.Name))
      if err != nil {
          return fmt.Errorf(&quot;failed to determine if file: %s is a unix domain socket: %v&quot;, event.Name, err)
      }
      if !isSocket {
          klog.V(5).InfoS(&quot;Ignoring non socket file&quot;, &quot;path&quot;, fi.Name())
          return nil
      }

      return w.handlePluginRegistration(event.Name)
  }

  return w.traversePluginDir(event.Name)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h3 id=&quot;reconcile&quot;&gt;reconcile&lt;/h3&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reconciler&lt;/code&gt; 是一个接口，它会运行一个周期性的循环通过调用注册和注销方法不断的reconcile现实和期望状态。&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Reconciler interface {
  // 启动一个reconciliation周期性的检查plugin是否被正确的注册和注销。
  Run(stopCh &amp;lt;-chan struct{})

  // AddHandler 会添加指定plugin类型的处理函数。这些处理函数也会被添加到actual state of world缓存中
  AddHandler(pluginType string, pluginHandler cache.PluginHandler)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建实例的操作：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func NewPluginManager(
...
    reconciler := reconciler.NewReconciler(
        operationexecutor.NewOperationExecutor(
            operationexecutor.NewOperationGenerator(
                recorder,
            ),
        ),
        loopSleepDuration,
        dsw,
        asw,
    )
...
}

func NewReconciler(
    operationExecutor operationexecutor.OperationExecutor,
    loopSleepDuration time.Duration,
    desiredStateOfWorld cache.DesiredStateOfWorld,
    actualStateOfWorld cache.ActualStateOfWorld) Reconciler {
    return &amp;amp;reconciler{
        operationExecutor:   operationExecutor,
        loopSleepDuration:   loopSleepDuration,
        desiredStateOfWorld: desiredStateOfWorld,
        actualStateOfWorld:  actualStateOfWorld,
        handlers:            make(map[string]cache.PluginHandler),
    }
}

type reconciler struct {
    operationExecutor   operationexecutor.OperationExecutor
    loopSleepDuration   time.Duration
    desiredStateOfWorld cache.DesiredStateOfWorld
    actualStateOfWorld  cache.ActualStateOfWorld
    handlers            map[string]cache.PluginHandler
    sync.RWMutex
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实现主要包含如下内容：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;actualStateOfWorld：&lt;a href=&quot;#actualstateofworld&quot;&gt;前文&lt;/a&gt;已经详细描述过，表示真实世界的状态，例如哪些plugin已经被注册，哪些plugin已经被注销。&lt;/li&gt;
  &lt;li&gt;desiredStateOfWorld：&lt;a href=&quot;#desiredstateofworld&quot;&gt;前文&lt;/a&gt;已经详细描述过，表示期望世界的状态，例如哪些plugin需要被注册，哪些plugin需要被注销。&lt;/li&gt;
  &lt;li&gt;operationExecutor：执行注册和注销plugin的函数。&lt;/li&gt;
  &lt;li&gt;loopSleepDuration： reconcile的时间间隔。&lt;/li&gt;
  &lt;li&gt;handlers: Plugin的处理函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reconcile的主要逻辑包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果plugin在desiredStateOfWorld中存在，但在actualStateOfWorld不存在或者没有正确的timestamp，则使用operationExecutor.RegisterPlugin注册Plugin&lt;/li&gt;
  &lt;li&gt;如果plugin在actualStateOfWorld中存在，但是在desiredStateOfWorld不存在或者timestampe不一样，则operationExecutor.UnregisterPlugin注销Plugin
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (rc *reconciler) reconcile() {
  // Unregisterations are triggered before registrations

  // Ensure plugins that should be unregistered are unregistered.
  for _, registeredPlugin := range rc.actualStateOfWorld.GetRegisteredPlugins() {
      unregisterPlugin := false
      if !rc.desiredStateOfWorld.PluginExists(registeredPlugin.SocketPath) {
          unregisterPlugin = true
      } else {
          // We also need to unregister the plugins that exist in both actual state of world
          // and desired state of world cache, but the timestamps don&apos;t match.
          // Iterate through desired state of world plugins and see if there&apos;s any plugin
          // with the same socket path but different timestamp.
          for _, dswPlugin := range rc.desiredStateOfWorld.GetPluginsToRegister() {
              if dswPlugin.SocketPath == registeredPlugin.SocketPath &amp;amp;&amp;amp; dswPlugin.Timestamp != registeredPlugin.Timestamp {
                  klog.V(5).InfoS(&quot;An updated version of plugin has been found, unregistering the plugin first before reregistering&quot;, &quot;plugin&quot;, registeredPlugin)
                  unregisterPlugin = true
                  break
              }
          }
      }

      if unregisterPlugin {
          klog.V(5).InfoS(&quot;Starting operationExecutor.UnregisterPlugin&quot;, &quot;plugin&quot;, registeredPlugin)
          err := rc.operationExecutor.UnregisterPlugin(registeredPlugin, rc.actualStateOfWorld)
          if err != nil &amp;amp;&amp;amp;
              !goroutinemap.IsAlreadyExists(err) &amp;amp;&amp;amp;
              !exponentialbackoff.IsExponentialBackoff(err) {
              // Ignore goroutinemap.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
              // Log all other errors.
              klog.ErrorS(err, &quot;OperationExecutor.UnregisterPlugin failed&quot;, &quot;plugin&quot;, registeredPlugin)
          }
          if err == nil {
              klog.V(1).InfoS(&quot;OperationExecutor.UnregisterPlugin started&quot;, &quot;plugin&quot;, registeredPlugin)
          }
      }
  }

  // Ensure plugins that should be registered are registered
  for _, pluginToRegister := range rc.desiredStateOfWorld.GetPluginsToRegister() {
      if !rc.actualStateOfWorld.PluginExistsWithCorrectTimestamp(pluginToRegister) {
          klog.V(5).InfoS(&quot;Starting operationExecutor.RegisterPlugin&quot;, &quot;plugin&quot;, pluginToRegister)
          err := rc.operationExecutor.RegisterPlugin(pluginToRegister.SocketPath, pluginToRegister.Timestamp, rc.getHandlers(), rc.actualStateOfWorld)
          if err != nil &amp;amp;&amp;amp;
              !goroutinemap.IsAlreadyExists(err) &amp;amp;&amp;amp;
              !exponentialbackoff.IsExponentialBackoff(err) {
              // Ignore goroutinemap.IsAlreadyExists and exponentialbackoff.IsExponentialBackoff errors, they are expected.
              klog.ErrorS(err, &quot;OperationExecutor.RegisterPlugin failed&quot;, &quot;plugin&quot;, pluginToRegister)
          }
          if err == nil {
              klog.V(1).InfoS(&quot;OperationExecutor.RegisterPlugin started&quot;, &quot;plugin&quot;, pluginToRegister)
          }
      }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h4 id=&quot;operationexector&quot;&gt;OperationExector&lt;/h4&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OperationExector&lt;/code&gt;是一个接口，主要作用是保证对于每一个Plugin的注册Socket只会产生一个协程操作：&lt;/p&gt;
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type OperationExecutor interface {
  // RegisterPlugin 使用handler map中的handler注册plugin，完成之后更新actual state.
  RegisterPlugin(socketPath string, timestamp time.Time, pluginHandlers map[string]cache.PluginHandler, actualStateOfWorld ActualStateOfWorldUpdater) error

  // UnregisterPlugin 使用handler map中的handler注销plugin，完成之后更新actual state
  UnregisterPlugin(pluginInfo cache.PluginInfo, actualStateOfWorld ActualStateOfWorldUpdater) error
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建实例：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func NewOperationExecutor(
    operationGenerator OperationGenerator) OperationExecutor {

    return &amp;amp;operationExecutor{
        pendingOperations:  goroutinemap.NewGoRoutineMap(true /* exponentialBackOffOnError */),
        operationGenerator: operationGenerator,
    }
}
type operationExecutor struct {
    // pendingOperations keeps track of pending attach and detach operations so
    // multiple operations are not started on the same volume
    pendingOperations goroutinemap.GoRoutineMap

    // operationGenerator is an interface that provides implementations for
    // generating volume function
    operationGenerator OperationGenerator
}

func (oe *operationExecutor) RegisterPlugin(
    socketPath string,
    timestamp time.Time,
    pluginHandlers map[string]cache.PluginHandler,
    actualStateOfWorld ActualStateOfWorldUpdater) error {
    generatedOperation :=
        oe.operationGenerator.GenerateRegisterPluginFunc(socketPath, timestamp, pluginHandlers, actualStateOfWorld)

    return oe.pendingOperations.Run(
        socketPath, generatedOperation)
}

func (oe *operationExecutor) UnregisterPlugin(
    pluginInfo cache.PluginInfo,
    actualStateOfWorld ActualStateOfWorldUpdater) error {
    generatedOperation :=
        oe.operationGenerator.GenerateUnregisterPluginFunc(pluginInfo, actualStateOfWorld)

    return oe.pendingOperations.Run(
        pluginInfo.SocketPath, generatedOperation)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;operationgenerator&quot;&gt;OperationGenerator&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    reconciler := reconciler.NewReconciler(
        operationexecutor.NewOperationExecutor(
            operationexecutor.NewOperationGenerator(
                recorder,
            ),
        ),
        loopSleepDuration,
        dsw,
        asw,
    )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OperationGenerator&lt;/code&gt;是一个interface，主要用来生成注册和注销Plugin的方法：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// OperationGenerator interface that extracts out the functions from operation_executor to make it dependency injectable
type OperationGenerator interface {
    // Generates the RegisterPlugin function needed to perform the registration of a plugin
    GenerateRegisterPluginFunc(
        socketPath string,
        timestamp time.Time,
        pluginHandlers map[string]cache.PluginHandler,
        actualStateOfWorldUpdater ActualStateOfWorldUpdater) func() error

    // Generates the UnregisterPlugin function needed to perform the unregistration of a plugin
    GenerateUnregisterPluginFunc(
        pluginInfo cache.PluginInfo,
        actualStateOfWorldUpdater ActualStateOfWorldUpdater) func() error
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;生成的RegisterPlugin方法使用两个gRPC接口：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GetInfo：用来获取Plugin的基本信息，包括Plugin Socket Endpoint。&lt;/li&gt;
  &lt;li&gt;NotifyRegistrationStatus：用来通知plugin注册的结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;并调用handler中的ValidatePlugin和RegisterPlugin，完成之后将handler同plugininfo一起放入actualStateOfWorld中。&lt;/p&gt;

&lt;p&gt;生成的UnRegisterPlugin方法不使用gRPC接口，只调用handler中的DeRegisterPlugin方法，完成之后从actualStateOfWorld中移除plugin。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (og *operationGenerator) GenerateRegisterPluginFunc(
    socketPath string,
    timestamp time.Time,
    pluginHandlers map[string]cache.PluginHandler,
    actualStateOfWorldUpdater ActualStateOfWorldUpdater) func() error {

    registerPluginFunc := func() error {
        client, conn, err := dial(socketPath, dialTimeoutDuration)
        if err != nil {
            return fmt.Errorf(&quot;RegisterPlugin error -- dial failed at socket %s, err: %v&quot;, socketPath, err)
        }
        defer conn.Close()

        ctx, cancel := context.WithTimeout(context.Background(), time.Second)
        defer cancel()

        infoResp, err := client.GetInfo(ctx, &amp;amp;registerapi.InfoRequest{})
        if err != nil {
            return fmt.Errorf(&quot;RegisterPlugin error -- failed to get plugin info using RPC GetInfo at socket %s, err: %v&quot;, socketPath, err)
        }

        handler, ok := pluginHandlers[infoResp.Type]
        if !ok {
            if err := og.notifyPlugin(client, false, fmt.Sprintf(&quot;RegisterPlugin error -- no handler registered for plugin type: %s at socket %s&quot;, infoResp.Type, socketPath)); err != nil {
                return fmt.Errorf(&quot;RegisterPlugin error -- failed to send error at socket %s, err: %v&quot;, socketPath, err)
            }
            return fmt.Errorf(&quot;RegisterPlugin error -- no handler registered for plugin type: %s at socket %s&quot;, infoResp.Type, socketPath)
        }

        if infoResp.Endpoint == &quot;&quot; {
            infoResp.Endpoint = socketPath
        }
        if err := handler.ValidatePlugin(infoResp.Name, infoResp.Endpoint, infoResp.SupportedVersions); err != nil {
            if err = og.notifyPlugin(client, false, fmt.Sprintf(&quot;RegisterPlugin error -- plugin validation failed with err: %v&quot;, err)); err != nil {
                return fmt.Errorf(&quot;RegisterPlugin error -- failed to send error at socket %s, err: %v&quot;, socketPath, err)
            }
            return fmt.Errorf(&quot;RegisterPlugin error -- pluginHandler.ValidatePluginFunc failed&quot;)
        }
        // We add the plugin to the actual state of world cache before calling a plugin consumer&apos;s Register handle
        // so that if we receive a delete event during Register Plugin, we can process it as a DeRegister call.
        err = actualStateOfWorldUpdater.AddPlugin(cache.PluginInfo{
            SocketPath: socketPath,
            Timestamp:  timestamp,
            Handler:    handler,
            Name:       infoResp.Name,
        })
        if err != nil {
            klog.ErrorS(err, &quot;RegisterPlugin error -- failed to add plugin&quot;, &quot;path&quot;, socketPath)
        }
        if err := handler.RegisterPlugin(infoResp.Name, infoResp.Endpoint, infoResp.SupportedVersions); err != nil {
            return og.notifyPlugin(client, false, fmt.Sprintf(&quot;RegisterPlugin error -- plugin registration failed with err: %v&quot;, err))
        }

        // Notify is called after register to guarantee that even if notify throws an error Register will always be called after validate
        if err := og.notifyPlugin(client, true, &quot;&quot;); err != nil {
            return fmt.Errorf(&quot;RegisterPlugin error -- failed to send registration status at socket %s, err: %v&quot;, socketPath, err)
        }
        return nil
    }
    return registerPluginFunc
}

func (og *operationGenerator) GenerateUnregisterPluginFunc(
    pluginInfo cache.PluginInfo,
    actualStateOfWorldUpdater ActualStateOfWorldUpdater) func() error {

    unregisterPluginFunc := func() error {
        if pluginInfo.Handler == nil {
            return fmt.Errorf(&quot;UnregisterPlugin error -- failed to get plugin handler for %s&quot;, pluginInfo.SocketPath)
        }
        // We remove the plugin to the actual state of world cache before calling a plugin consumer&apos;s Unregister handle
        // so that if we receive a register event during Register Plugin, we can process it as a Register call.
        actualStateOfWorldUpdater.RemovePlugin(pluginInfo.SocketPath)

        pluginInfo.Handler.DeRegisterPlugin(pluginInfo.Name)

        klog.V(4).InfoS(&quot;DeRegisterPlugin called&quot;, &quot;pluginName&quot;, pluginInfo.Name, &quot;pluginHandler&quot;, pluginInfo.Handler)
        return nil
    }
    return unregisterPluginFunc
}

func (og *operationGenerator) notifyPlugin(client registerapi.RegistrationClient, registered bool, errStr string) error {
    ctx, cancel := context.WithTimeout(context.Background(), notifyTimeoutDuration)
    defer cancel()

    status := &amp;amp;registerapi.RegistrationStatus{
        PluginRegistered: registered,
        Error:            errStr,
    }

    if _, err := client.NotifyRegistrationStatus(ctx, status); err != nil {
        return fmt.Errorf(&quot;%s: %w&quot;, errStr, err)
    }

    if errStr != &quot;&quot; {
        return errors.New(errStr)
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;csi-plugin-handler&quot;&gt;CSI Plugin Handler&lt;/h2&gt;
&lt;p&gt;CSI Plugin Handler需实现Plugin Handler接口：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type PluginHandler interface {
    // Validate returns an error if the information provided by
    // the potential plugin is erroneous (unsupported version, ...)
    ValidatePlugin(pluginName string, endpoint string, versions []string) error
    // RegisterPlugin is called so that the plugin can be register by any
    // plugin consumer
    // Error encountered here can still be Notified to the plugin.
    RegisterPlugin(pluginName, endpoint string, versions []string) error
    // DeRegister is called once the pluginwatcher observes that the socket has
    // been deleted.
    DeRegisterPlugin(pluginName string)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CSI Plugin Handler的实例为：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kl.pluginManager.AddHandler(pluginwatcherapi.CSIPlugin, plugincache.PluginHandler(csi.PluginHandler))
...
var PluginHandler = &amp;amp;RegistrationHandler{}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其ValidatePlugin方法主要为了检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;是否已经有更高版本的Driver已经被注册&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (h *RegistrationHandler) ValidatePlugin(pluginName string, endpoint string, versions []string) error {
    klog.Infof(log(&quot;Trying to validate a new CSI Driver with name: %s endpoint: %s versions: %s&quot;,
        pluginName, endpoint, strings.Join(versions, &quot;,&quot;)))

    _, err := h.validateVersions(&quot;ValidatePlugin&quot;, pluginName, endpoint, versions)
    if err != nil {
        return fmt.Errorf(&quot;validation failed for CSI Driver %s at endpoint %s: %v&quot;, pluginName, endpoint, err)
    }

    return err
}
//检查CSI Driver注册的plugin是否已经有更高的版本被注册过
func (h *RegistrationHandler) validateVersions(callerName, pluginName string, endpoint string, versions []string) (*utilversion.Version, error) {
    if len(versions) == 0 {
        return nil, errors.New(log(&quot;%s for CSI driver %q failed. Plugin returned an empty list for supported versions&quot;, callerName, pluginName))
    }

    // Validate version
    newDriverHighestVersion, err := highestSupportedVersion(versions)
    if err != nil {
        return nil, errors.New(log(&quot;%s for CSI driver %q failed. None of the versions specified %q are supported. err=%v&quot;, callerName, pluginName, versions, err))
    }

    existingDriver, driverExists := csiDrivers.Get(pluginName)
    if driverExists {
        if !existingDriver.highestSupportedVersion.LessThan(newDriverHighestVersion) {
            return nil, errors.New(log(&quot;%s for CSI driver %q failed. Another driver with the same name is already registered with a higher supported version: %q&quot;, callerName, pluginName, existingDriver.highestSupportedVersion))
        }
    }

    return newDriverHighestVersion, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;RegisterPlugin方法主要包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;获取CSI支持的最高版本&lt;/li&gt;
  &lt;li&gt;将Driver的endpoint和最高版本保存在csiDriver的集合中&lt;/li&gt;
  &lt;li&gt;从csiDriver获取gRPC endpoint初始化Client&lt;/li&gt;
  &lt;li&gt;调用NodeGetInfo接口，更新Node对象的node ID annotation，并且更新CSINode对象中的CSIDrivers字段，如果CSINode对象不存在，则创建一个新的。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// RegisterPlugin is called when a plugin can be registered
func (h *RegistrationHandler) RegisterPlugin(pluginName string, endpoint string, versions []string) error {
    klog.Infof(log(&quot;Register new plugin with name: %s at endpoint: %s&quot;, pluginName, endpoint))

    highestSupportedVersion, err := h.validateVersions(&quot;RegisterPlugin&quot;, pluginName, endpoint, versions)
    if err != nil {
        return err
    }

    // Storing endpoint of newly registered CSI driver into the map, where CSI driver name will be the key
    // all other CSI components will be able to get the actual socket of CSI drivers by its name.
    csiDrivers.Set(pluginName, Driver{
        endpoint:                endpoint,
        highestSupportedVersion: highestSupportedVersion,
    })

    // Get node info from the driver.
    csi, err := newCsiDriverClient(csiDriverName(pluginName))
    if err != nil {
        return err
    }

    ctx, cancel := context.WithTimeout(context.Background(), csiTimeout)
    defer cancel()

    driverNodeID, maxVolumePerNode, accessibleTopology, err := csi.NodeGetInfo(ctx)
    if err != nil {
        if unregErr := unregisterDriver(pluginName); unregErr != nil {
            klog.Error(log(&quot;registrationHandler.RegisterPlugin failed to unregister plugin due to previous error: %v&quot;, unregErr))
        }
        return err
    }

    err = nim.InstallCSIDriver(pluginName, driverNodeID, maxVolumePerNode, accessibleTopology)
    if err != nil {
        if unregErr := unregisterDriver(pluginName); unregErr != nil {
            klog.Error(log(&quot;registrationHandler.RegisterPlugin failed to unregister plugin due to previous error: %v&quot;, unregErr))
        }
        return err
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;DeRegisterPlugin主要包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从csiDrivers中删除plugin&lt;/li&gt;
  &lt;li&gt;清理Node对象的node ID annotation，并且清除CSINode对象中的CSIDrivers字段。
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (h *RegistrationHandler) DeRegisterPlugin(pluginName string) {
  klog.Info(log(&quot;registrationHandler.DeRegisterPlugin request for plugin %s&quot;, pluginName))
  if err := unregisterDriver(pluginName); err != nil {
      klog.Error(log(&quot;registrationHandler.DeRegisterPlugin failed: %v&quot;, err))
  }
}
func unregisterDriver(driverName string) error {
  csiDrivers.Delete(driverName)

  if err := nim.UninstallCSIDriver(driverName); err != nil {
      return errors.New(log(&quot;Error uninstalling CSI driver: %v&quot;, err))
  }

  return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h2 id=&quot;containermanger-pluginregistrationhandler&quot;&gt;ContainerManger PluginRegistrationHandler&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用plugin-manager&quot;&gt;使用Plugin Manager&lt;/h3&gt;
&lt;p&gt;我们首先找到Device Plugin的handle所在。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kl.pluginManager.AddHandler(pluginwatcherapi.DevicePlugin, kl.containerManager.GetPluginRegistrationHandler())

...

kubeDeps.ContainerManager, err = cm.NewContainerManager(...)

...

func NewContainerManager(mountUtil mount.Interface, cadvisorInterface cadvisor.Interface, nodeConfig NodeConfig, failSwapOn bool, devicePluginEnabled bool, recorder record.EventRecorder) (ContainerManager, error) {
    ...
    cm := &amp;amp;containerManagerImpl{
        cadvisorInterface:   cadvisorInterface,
        mountUtil:           mountUtil,
        NodeConfig:          nodeConfig,
        subsystems:          subsystems,
        cgroupManager:       cgroupManager,
        capacity:            capacity,
        internalCapacity:    internalCapacity,
        cgroupRoot:          cgroupRoot,
        recorder:            recorder,
        qosContainerManager: qosContainerManager,
    }
    ...
    klog.InfoS(&quot;Creating device plugin manager&quot;, &quot;devicePluginEnabled&quot;, devicePluginEnabled)
    if devicePluginEnabled {
        cm.deviceManager, err = devicemanager.NewManagerImpl(machineInfo.Topology, cm.topologyManager)
        cm.topologyManager.AddHintProvider(cm.deviceManager)
    } else {
        cm.deviceManager, err = devicemanager.NewManagerStub()
    }
    ...
}

...

func (cm *containerManagerImpl) GetPluginRegistrationHandler() cache.PluginHandler {
    return cm.deviceManager.GetWatcherHandler()
}

...

// NewManagerImpl creates a new manager.
func NewManagerImpl(topology []cadvisorapi.Node, topologyAffinityStore topologymanager.Store) (*ManagerImpl, error) {
    socketPath := pluginapi.KubeletSocket
    if runtime.GOOS == &quot;windows&quot; {
        socketPath = os.Getenv(&quot;SYSTEMDRIVE&quot;) + pluginapi.KubeletSocketWindows
    }
    return newManagerImpl(socketPath, topology, topologyAffinityStore)
}


// GetWatcherHandler returns the plugin handler
func (m *ManagerImpl) GetWatcherHandler() cache.PluginHandler {
    // socketdir: /var/lib/kubelet/device-plugins/
    if f, err := os.Create(m.socketdir + &quot;DEPRECATION&quot;); err != nil {
        klog.ErrorS(err, &quot;Failed to create deprecation file at socket dir&quot;, &quot;path&quot;, m.socketdir)
    } else {
        f.Close()
        klog.V(4).InfoS(&quot;Created deprecation file&quot;, &quot;path&quot;, f.Name())
    }
    return cache.PluginHandler(m)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;顺藤摸瓜，我们找到了Device Manger实现的Plugin Handler。&lt;/p&gt;

&lt;p&gt;ValidatePlugin负责：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;检查plugin是否含有pluginapi.SupportedVersions，目前只包含v1beta1。&lt;/li&gt;
  &lt;li&gt;检查pluginName的格式是否符合ExtendedResourceName&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;RegisterPlugin负责：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;调用GetDevicePluginOptions接口&lt;/li&gt;
  &lt;li&gt;将plugin信息放入m.endpoints&lt;/li&gt;
  &lt;li&gt;调用ListAndWatch接口，更新该plugin所管辖的资源状态&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;DeRegisterPlugin负责：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;停止m.endpoints中相应gRPC链接，并更新停止时间。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ValidatePlugin validates a plugin if the version is correct and the name has the format of an extended resource
func (m *ManagerImpl) ValidatePlugin(pluginName string, endpoint string, versions []string) error {
    klog.V(2).InfoS(&quot;Got Plugin at endpoint with versions&quot;, &quot;plugin&quot;, pluginName, &quot;endpoint&quot;, endpoint, &quot;versions&quot;, versions)

    if !m.isVersionCompatibleWithPlugin(versions) {
        return fmt.Errorf(&quot;manager version, %s, is not among plugin supported versions %v&quot;, pluginapi.Version, versions)
    }

    if !v1helper.IsExtendedResourceName(v1.ResourceName(pluginName)) {
        return fmt.Errorf(&quot;invalid name of device plugin socket: %s&quot;, fmt.Sprintf(errInvalidResourceName, pluginName))
    }

    return nil
}

// RegisterPlugin starts the endpoint and registers it
// TODO: Start the endpoint and wait for the First ListAndWatch call
//       before registering the plugin
func (m *ManagerImpl) RegisterPlugin(pluginName string, endpoint string, versions []string) error {
    klog.V(2).InfoS(&quot;Registering plugin at endpoint&quot;, &quot;plugin&quot;, pluginName, &quot;endpoint&quot;, endpoint)

    e, err := newEndpointImpl(endpoint, pluginName, m.callback)
    if err != nil {
        return fmt.Errorf(&quot;failed to dial device plugin with socketPath %s: %v&quot;, endpoint, err)
    }

    options, err := e.client.GetDevicePluginOptions(context.Background(), &amp;amp;pluginapi.Empty{})
    if err != nil {
        return fmt.Errorf(&quot;failed to get device plugin options: %v&quot;, err)
    }

    m.registerEndpoint(pluginName, options, e)
    go m.runEndpoint(pluginName, e)

    return nil
}

// DeRegisterPlugin deregisters the plugin
// TODO work on the behavior for deregistering plugins
// e.g: Should we delete the resource
func (m *ManagerImpl) DeRegisterPlugin(pluginName string) {
    m.mutex.Lock()
    defer m.mutex.Unlock()

    // Note: This will mark the resource unhealthy as per the behavior
    // in runEndpoint
    if eI, ok := m.endpoints[pluginName]; ok {
        eI.e.stop()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用register接口&quot;&gt;使用Register接口&lt;/h3&gt;

&lt;p&gt;Device Plugin还可以调用Kubelet提供的Register接口注册服务。Register接口提供的服务和ValidatePlugin + RegisterPlugin 接口提供的服务是一样的。区别在于Plugin Manager会自动发现注册Socket，然后找到Plugin Socket。而Register接口则是要求Plugin主动向Kubelet发起注册请求。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Register registers a device plugin.
func (m *ManagerImpl) Register(ctx context.Context, r *pluginapi.RegisterRequest) (*pluginapi.Empty, error) {
    klog.InfoS(&quot;Got registration request from device plugin with resource&quot;, &quot;resourceName&quot;, r.ResourceName)
    metrics.DevicePluginRegistrationCount.WithLabelValues(r.ResourceName).Inc()
    var versionCompatible bool
    for _, v := range pluginapi.SupportedVersions {
        if r.Version == v {
            versionCompatible = true
            break
        }
    }
    if !versionCompatible {
        err := fmt.Errorf(errUnsupportedVersion, r.Version, pluginapi.SupportedVersions)
        klog.InfoS(&quot;Bad registration request from device plugin with resource&quot;, &quot;resourceName&quot;, r.ResourceName, &quot;err&quot;, err)
        return &amp;amp;pluginapi.Empty{}, err
    }

    if !v1helper.IsExtendedResourceName(v1.ResourceName(r.ResourceName)) {
        err := fmt.Errorf(errInvalidResourceName, r.ResourceName)
        klog.InfoS(&quot;Bad registration request from device plugin&quot;, &quot;err&quot;, err)
        return &amp;amp;pluginapi.Empty{}, err
    }

    // TODO: for now, always accepts newest device plugin. Later may consider to
    // add some policies here, e.g., verify whether an old device plugin with the
    // same resource name is still alive to determine whether we want to accept
    // the new registration.
    go m.addEndpoint(r)

    return &amp;amp;pluginapi.Empty{}, nil
}

func (m *ManagerImpl) addEndpoint(r *pluginapi.RegisterRequest) {
    new, err := newEndpointImpl(filepath.Join(m.socketdir, r.Endpoint), r.ResourceName, m.callback)
    if err != nil {
        klog.ErrorS(err, &quot;Failed to dial device plugin with request&quot;, &quot;request&quot;, r)
        return
    }
    m.registerEndpoint(r.ResourceName, r.Options, new)
    go func() {
        m.runEndpoint(r.ResourceName, new)
    }()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/design-proposals-archive/blob/main/node/plugin-watcher.md&quot;&gt;Plugin Watcher Utility&lt;/a&gt;
&lt;img src=&quot;../../../assets/images/posts/kubelet_registration.drawio.png&quot; alt=&quot;Image&quot; class=&quot;rounded&quot; /&gt;&lt;/p&gt;</content><author><name>Johan Wang</name><email>youhangwang@foxmail.com</email></author><category term="Kubelet" /><category term="PluginRegistration" /><summary type="html">可扩展性是Kubernetes一直所遵循的设计哲学。Kubelet在实现上使用Plugin模式在无需修改核心代码的前提下实现功能扩展。</summary></entry><entry><title type="html">本地运行 Kubernetes Webhook</title><link href="http://localhost:4000/2021/12/16/webhook-local-run.html" rel="alternate" type="text/html" title="本地运行 Kubernetes Webhook" /><published>2021-12-16T00:00:00+08:00</published><updated>2021-12-16T00:00:00+08:00</updated><id>http://localhost:4000/2021/12/16/webhook-local-run</id><content type="html" xml:base="http://localhost:4000/2021/12/16/webhook-local-run.html">&lt;p&gt;Kubernetes提供了动态Webhook机制，它是一种用于接收准入请求并对其进行处理的HTTP回调机制。主要包括两种类型：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;validation webhook&lt;/li&gt;
  &lt;li&gt;mutation webhook&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中Mutation Webhook会先于Validation Webhook调用，目的是保证Validation Webhook能够对资源的所有修改都进行验证。为了保证Apiserver到Webhook的网络安全，Apiserver使用HTTPS协议同webhook通信。
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;p&gt;如果读者开发过Operator，那么一定有过这样的使用经验：本地运行controller读取config文件同远端的Kube Apiserver通信，这样可以直接在本地修改代码并实时运行进行debug。&lt;/p&gt;

&lt;p&gt;不同于Controller到Apiserver之间的网络连接，webhook到Apiserver的连接是由Apiserver发起的，所以如果想让Webhook像Controller一样能够本地运行方便debug，则要求Apiserver可以主动向webhook server发起网络请求。&lt;/p&gt;

&lt;p&gt;本地运行Webhook需要完成以下步骤：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用Cert-Manager在集群中创建Certficate&lt;/li&gt;
  &lt;li&gt;将创建好的Cert Copy到本地，方便本地运行的Webhook使用该证书&lt;/li&gt;
  &lt;li&gt;本地运行Webhook&lt;/li&gt;
  &lt;li&gt;在Cluster中创建ValidatingWebhookConfiguration或者Mutatingwebhookconfigurations&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述步骤与正常使用Webhook的配置并无本质上的区别，但是细节上有一些不同。&lt;/p&gt;

&lt;h2 id=&quot;创建certificate&quot;&gt;创建Certificate&lt;/h2&gt;

&lt;p&gt;正常使用Webhook时，Cert都是针对该Webhook Service DNS创建的。但是在本地run webhook时，需要使用本机IP。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: k8s-webhook-local-run-serving-cert
  namespace: k8s-webhook-local-run-system
spec:
  ipAddresses:
  - &amp;lt;local ip address&amp;gt;
  issuerRef:
    kind: Issuer
    name: k8s-webhook-local-run-selfsigned-issuer
  secretName: webhook-server-cert
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果使用的Cluster是在Mac OS上使用KinD创建的，Docker会为本地IP自动创建一个DNS &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;host.docker.internal&lt;/code&gt;。也可以使用该DNS创建Cert：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: k8s-webhook-local-run-serving-cert
  namespace: k8s-webhook-local-run-system
spec:
  dnsNames:
  - host.docker.internal
  issuerRef:
    kind: Issuer
    name: k8s-webhook-local-run-selfsigned-issuer
  secretName: webhook-server-cert
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;从集群中复制cert到本地&quot;&gt;从集群中复制Cert到本地&lt;/h2&gt;

&lt;p&gt;当Cert-Manager将证书创建成功时，会生成一个Secret保存相关文件。找到Secret，将其内容以文件的形式复制到本地。&lt;/p&gt;

&lt;h2 id=&quot;本地运行webhook&quot;&gt;本地运行Webhook&lt;/h2&gt;

&lt;p&gt;本地运行Webhook，请注意：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;推荐使用HTTPS端口443&lt;/li&gt;
  &lt;li&gt;证书地址配置为上一步中复制Cert的地址&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;创建validatingwebhookconfiguration或者mutatingwebhookconfigurations&quot;&gt;创建ValidatingWebhookConfiguration或者Mutatingwebhookconfigurations&lt;/h2&gt;

&lt;p&gt;ValidatingWebhookConfiguration和Mutatingwebhookconfigurations的配置类似，本文只以其中一种为例：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  annotations:
    cert-manager.io/inject-ca-from: &amp;lt;Cert-Namespace&amp;gt;/&amp;lt;Cert-Name&amp;gt;
  name: k8s-webhook-local-run-validating-webhook-configuration
webhooks:
- admissionReviewVersions:
  - v1
  clientConfig:
    url: https://&amp;lt;IP-Address-Or-DNS-In-Cert&amp;gt;/validate-webapp-my-domain-v1-guestbook
  failurePolicy: Fail
  name: vguestbook.kb.io
  rules:
  - apiGroups:
    - webapp.my.domain
    apiVersions:
    - v1
    operations:
    - CREATE
    - UPDATE
    resources:
    - guestbooks
  sideEffects: None
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中annotations.cert-manager.io/inject-ca-from的值为证书的namespace/name，该项的作用是使Apiserver承认Cert使用的CA。clientConfig.url为本地运行webhook的URL。&lt;/p&gt;

&lt;p&gt;一旦完成上述配置，则Kubernetes集群中Apiserver便可以调用Webhook相关URL。&lt;/p&gt;</content><author><name>Johan Wang</name><email>youhangwang@foxmail.com</email></author><category term="Kubernetes" /><category term="Webhook" /><summary type="html">Kubernetes提供了动态Webhook机制，它是一种用于接收准入请求并对其进行处理的HTTP回调机制。主要包括两种类型： validation webhook mutation webhook 其中Mutation Webhook会先于Validation Webhook调用，目的是保证Validation Webhook能够对资源的所有修改都进行验证。为了保证Apiserver到Webhook的网络安全，Apiserver使用HTTPS协议同webhook通信。</summary></entry><entry><title type="html">Kubernetes Patch and Update 机制</title><link href="http://localhost:4000/2021/12/01/update-patch.html" rel="alternate" type="text/html" title="Kubernetes Patch and Update 机制" /><published>2021-12-01T00:00:00+08:00</published><updated>2021-12-01T00:00:00+08:00</updated><id>http://localhost:4000/2021/12/01/update-patch</id><content type="html" xml:base="http://localhost:4000/2021/12/01/update-patch.html">&lt;p&gt;Kubernetes提供了两种更新资源的的机制: update和patch。本文将会介绍这这种方式的具体使用方法，区别和原理。
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;kubernetes-update-机制&quot;&gt;Kubernetes Update 机制&lt;/h2&gt;

&lt;p&gt;在kubernetes中，每个资源都有一个&lt;a href=&quot;https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions&quot;&gt;resourceversion&lt;/a&gt;，针对该资源的每次修改都会导致resourceversion的变化。借助resourceversion，Kubernetes Apiserver 采用了类似乐观锁的方式实现Update机制。&lt;/p&gt;

&lt;p&gt;当要对某个资源做Update操作时，需要带上该资源的resourceversion，Apiserver会检查请求中的resourceversion是否与server端保存的最新resourceversion一致：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果相同，则接受Update请求并改变server端该资源的的resourceversion&lt;/li&gt;
  &lt;li&gt;如果不相同，则返回有冲突的错误，此时由客户端决定接下去的步骤，例如是将错误直接返回给用户还是获取最新的版本然后重新发起Update请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kubernetes Client中使用Update：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Init kubernetes client here
k8sClient.Get(context.TODO(), types.NamespacedName{
	Namespace: &quot;default&quot;,
	Name:      &quot;my-sample&quot;,
}, object)

// Make changes to the objec here
k8sClient.Update(context.TODO(), object)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;kubernetes-patch-机制&quot;&gt;Kubernetes Patch 机制&lt;/h2&gt;

&lt;p&gt;Update需要传输整个object到Apiserver，使用的是PUT方法。而Patch只需要传输变化的部分给Apiserver，Kubernetes 支持的Patch方式一共有四种：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;json patch&lt;/li&gt;
  &lt;li&gt;json merge patch&lt;/li&gt;
  &lt;li&gt;strategic merge patch&lt;/li&gt;
  &lt;li&gt;apply patch
    &lt;ul&gt;
      &lt;li&gt;client-side apply patch&lt;/li&gt;
      &lt;li&gt;server-side apply patch&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;json-patch&quot;&gt;Json Patch&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc6902&quot;&gt;RFC6902&lt;/a&gt;定义了一种用于表示一系列对于目标Json操作的Json结构，它适用于HTTP PATCH方法。media type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/json-patch+json&lt;/code&gt; 用于标识此类Patch。&lt;/p&gt;

&lt;p&gt;Json patch是一系列json对象组成的列表，每一个json对象表示一个对目标json文件的操作，例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
    { &quot;op&quot;: &quot;test&quot;, &quot;path&quot;: &quot;/a/b/c&quot;, &quot;value&quot;: &quot;foo&quot; },
    { &quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/a/b/c&quot; },
    { &quot;op&quot;: &quot;add&quot;, &quot;path&quot;: &quot;/a/b/c&quot;, &quot;value&quot;: [ &quot;foo&quot;, &quot;bar&quot; ] },
    { &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/a/b/c&quot;, &quot;value&quot;: 42 },
    { &quot;op&quot;: &quot;move&quot;, &quot;from&quot;: &quot;/a/b/c&quot;, &quot;path&quot;: &quot;/a/b/d&quot; },
    { &quot;op&quot;: &quot;copy&quot;, &quot;from&quot;: &quot;/a/b/d&quot;, &quot;path&quot;: &quot;/a/b/e&quot; }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;操作按照它们在数组中出现的顺序依次生效。序列中的每个操作都应用于目标文档，生成的文档成为下一个操作的目标，直到成功应用所有操作或直到遇到错误条件。&lt;/p&gt;

&lt;p&gt;可以使用的操作包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;add&lt;/li&gt;
  &lt;li&gt;remove&lt;/li&gt;
  &lt;li&gt;replace&lt;/li&gt;
  &lt;li&gt;move&lt;/li&gt;
  &lt;li&gt;copy&lt;/li&gt;
  &lt;li&gt;test&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于Json patch中只包含一系列的操作而没有version字段，所以Apiserver没办法对Json patch施加乐观锁。&lt;/p&gt;

&lt;p&gt;为了方便演示Kubernetes Client的Patch功能，可以预先定义：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type JsonPatch []PatchOperation
type PatchOperation struct {
	Op    string      `json:&quot;op&quot;`
	Path  string      `json:&quot;path&quot;`
	From  string      `json:&quot;from,omitempty&quot;`
	Value interface{} `json:&quot;value,omitempty&quot;`
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;add&quot;&gt;add&lt;/h4&gt;

&lt;p&gt;Add操作的作用：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如果path是一个array的index，则value会插入到array中的相应位置，当前及其后元素的位置向后顺延。如果需要添加元素的位置&amp;gt;len(arrays)，则会报错。&lt;/li&gt;
  &lt;li&gt;如果path是一个不存在的object member，则新member会被加入。&lt;/li&gt;
  &lt;li&gt;如果path是一个已经存在的object member，则该member的值会被改变。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此操作的目的是添加元素到现有的对象和数组，其目标位置可能不存在。通常这会触发错误使用指针的报错，但Json patch中的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;会忽略该错误并添加指定的值。但是，对象本身或包含它的数组必须要存在。例如，目标位置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/a/b&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;操作作用于此文档：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ &quot;a&quot;: { &quot;foo&quot;: 1 } }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;尽管&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;中不存在member &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;，但这并不会导致错误，因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;存在，member &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt;将被添加到其值中。&lt;/p&gt;

&lt;p&gt;但如果作用于下面的这个json文档，会导致错误的发生：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ &quot;q&quot;: { &quot;bar&quot;: 2 } }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;不存在。&lt;/p&gt;

&lt;p&gt;Kubernetes Client中使用Json Patch对Deployment做Add操作：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := JsonPatch{
	PatchOperation{
		Op:    &quot;add&quot;,
		Path:  &quot;/metadata/annotations/provider-name&quot;,
		Value: &quot;my-provider&quot;,
	},
}
patchByte, err := json.Marshal(jsonPatch)
clientset, err := kubernetes.NewForConfig(ctrl.GetConfigOrDie())

deployment, err := clientset.AppsV1().Deployments(apiv1.NamespaceDefault).Patch(context.TODO(), &quot;my-deployment&quot;, types.JSONPatchType, patchByte, metav1.PatchOptions{})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;remove&quot;&gt;remove&lt;/h4&gt;

&lt;p&gt;Remove操作会移除目标位置的元素。目标位置必须存在才能使操作成功。例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ &quot;op&quot;: &quot;remove&quot;, &quot;path&quot;: &quot;/a/b/c&quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果从数组中删除一个元素，则指定索引右面的任何元素都将向左移动一个位置。&lt;/p&gt;

&lt;p&gt;Kubernetes Client中使用Json Patch对Deployment做Remove操作：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := JsonPatch{
	PatchOperation{
		Op:    &quot;remove&quot;,
		Path:  &quot;/metadata/annotations/provider-name&quot;,
		Value: &quot;my-provider&quot;,
	},
}
...
deployment, err := clientset.AppsV1().Deployments(apiv1.NamespaceDefault).Patch(context.TODO(), &quot;my-deployment&quot;, types.JSONPatchType, patchByte, metav1.PatchOptions{})

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;replace&quot;&gt;replace&lt;/h4&gt;

&lt;p&gt;Replace操作会用新值替换目标位置处的值。操作对象必须包含一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt;成员用来指定替换值。目标位置必须存在才能使操作成功。例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/a/b/c&quot;, &quot;value&quot;: 42 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Replace操作在功能上可以等效于对某个元素执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove&lt;/code&gt;操作，紧接着在与&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove&lt;/code&gt;操作相同的位置执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;操作。&lt;/p&gt;

&lt;p&gt;Kubernetes Client中使用Json Patch对Deployment做Remove操作：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := JsonPatch{
	PatchOperation{
		Op:    &quot;replace&quot;,
		Path:  &quot;/metadata/annotations/provider-name&quot;,
		Value: &quot;my-provider&quot;,
	},
}
...
deployment, err := clientset.AppsV1().Deployments(apiv1.NamespaceDefault).Patch(context.TODO(), &quot;my-deployment&quot;, types.JSONPatchType, patchByte, metav1.PatchOptions{})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;move&quot;&gt;move&lt;/h4&gt;

&lt;p&gt;Move操作移除指定位置的值并将其添加到目标位置。操作对象必须包含一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from&lt;/code&gt;成员，该值引用目标文档中要从中移动值的位置。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from&lt;/code&gt;位置必须存在才能使操作成功。例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ &quot;op&quot;: &quot;move&quot;, &quot;from&quot;: &quot;/a/b/c&quot;, &quot;path&quot;: &quot;/a/b/d&quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此操作在功能上可以等效于对某个元素执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from&lt;/code&gt;位置的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remove&lt;/code&gt;操作，紧接着在目标位置执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;操作。&lt;/p&gt;

&lt;p&gt;Kubernetes Client中使用Json Patch对Deployment做Move操作：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := JsonPatch{
	PatchOperation{
		Op:   &quot;move&quot;,
		From: &quot;/metadata/annotations/provider-name&quot;,
		Path: &quot;/metadata/labels/provider-name&quot;,
	},
}
...
deployment, err := clientset.AppsV1().Deployments(apiv1.NamespaceDefault).Patch(context.TODO(), &quot;my-deployment&quot;, types.JSONPatchType, patchByte, metav1.PatchOptions{})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;copy&quot;&gt;copy&lt;/h4&gt;

&lt;p&gt;Copy操作将指定位置的值复制到目标位置。操作对象必须包含一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from&lt;/code&gt;成员，该值引用目标文档中要从中复制值的位置。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from&lt;/code&gt;位置必须存在才能使操作成功。例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ &quot;op&quot;: &quot;copy&quot;, &quot;from&quot;: &quot;/a/b/c&quot;, &quot;path&quot;: &quot;/a/b/e&quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此操作在功能上可以等效于对目标位置执行&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add&lt;/code&gt;操作添加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from&lt;/code&gt;位置的值。&lt;/p&gt;

&lt;p&gt;Kubernetes Client中使用Json Patch对Deployment做Copy操作：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := JsonPatch{
	PatchOperation{
		Op:   &quot;copy&quot;,
		Path: &quot;/metadata/annotations/provider-name&quot;,
		From: &quot;/metadata/labels/provider-name&quot;,
	},
}
...
deployment, err := clientset.AppsV1().Deployments(apiv1.NamespaceDefault).Patch(context.TODO(), &quot;my-deployment&quot;, types.JSONPatchType, patchByte, metav1.PatchOptions{})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;test&quot;&gt;test&lt;/h4&gt;

&lt;p&gt;Test操作测试目标位置处的值是否等于指定值。操作对象必须包含一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt;成员，该成员表示要与目标位置的值进行比较的值。目标位置的值和json类型必须等于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt;中指定的值和json类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;string: 包含相同数量的Unicode字符并且逐字节相等.&lt;/li&gt;
  &lt;li&gt;number: 值在数字上相等。&lt;/li&gt;
  &lt;li&gt;arrays: 包含相同数量的值，并且每个值都可以被认为等于另一个数组中相应位置的值&lt;/li&gt;
  &lt;li&gt;objects: 包含相同数量的成员，并且较它们的键和它们的值都相等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ &quot;op&quot;: &quot;test&quot;, &quot;path&quot;: &quot;/a/b/c&quot;, &quot;value&quot;: &quot;foo&quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Kubernetes Client中使用Json Patch对Deployment做Test操作：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := JsonPatch{
	PatchOperation{
		Op:    &quot;test&quot;,
		Path:  &quot;/metadata/annotations/provider-name&quot;,
		Value: &quot;my-provider&quot;,
	},
}
...
deployment, err := clientset.AppsV1().Deployments(apiv1.NamespaceDefault).Patch(context.TODO(), &quot;my-deployment&quot;, types.JSONPatchType, patchByte, metav1.PatchOptions{})
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;json-merge-patch&quot;&gt;Json Merge Patch&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7386&quot;&gt;RFC7386&lt;/a&gt;定义了JSON Merge Patch的格式和处理规则。它适用于HTTP PATCH方法。media type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge-patch+json&lt;/code&gt;用于标识此类Patch。&lt;/p&gt;

&lt;p&gt;JSON Merge Patch文档描述了对目标 JSON 文档所做的更改，使用的语法与正在修改的文档非常相似。Merge Patch文档的接收者通过将所提供Patch的内容与目标文档的当前内容进行比较来确定所请求的确切更改集。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果提供的Patch包含未出现在目标中的成员，则会添加这些成员。&lt;/li&gt;
  &lt;li&gt;如果目标确实包含该成员，则替换该值。&lt;/li&gt;
  &lt;li&gt;Patch中的null被赋予特殊含义以指示删除目标中的现有值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如, 原始json文件的内容如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;a&quot;: &quot;b&quot;,
    &quot;c&quot;: {
        &quot;d&quot;: &quot;e&quot;,
        &quot;f&quot;: &quot;g&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用如下Merge Patch可以更改a的值并且删除元素f，其他元素保持不变:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    &quot;a&quot;:&quot;z&quot;,
    &quot;c&quot;: {
       &quot;f&quot;: null
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该方法有几点需要注意:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果Patch内容不是对象，则将用整个Patch替换目标。这导致无法仅替换数组中的某些值。&lt;/li&gt;
  &lt;li&gt;仅适用于不使用显式Null的JSON文档的修改。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kubernetes Client中使用Json Merge Patch：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := []byte(`{
	&quot;metadata&quot;:{
		&quot;annotations&quot;: {
			&quot;provider-name&quot;: &quot;my-provider&quot;
		}
	}
}
`)
...
deployment, err := clientset.AppsV1().Deployments(apiv1.NamespaceDefault).Patch(context.TODO(), &quot;my-deployment&quot;, types.MergePatchType, jsonPatch, metav1.PatchOptions{})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;optimistic-lock&quot;&gt;Optimistic Lock&lt;/h4&gt;
&lt;p&gt;Kubernetes Client 在json merge patch功能中支持乐观锁，但是需要在patch文件中指明resourceversion，例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := []byte(`{
	&quot;metadata&quot;:{
		&quot;annotations&quot;: {
			&quot;provider-name&quot;: &quot;my-provider&quot;
		},
		&quot;resourceVersion&quot;: &quot;1501414&quot;
	}
}
`)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;只有Merge Patch中的resourceversion与Apiserver中最新的resourceversion相同时，patch才会成功。如果不相同，则返回错误&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Operation cannot be fulfilled on deployments.apps &quot;my-deployment&quot;: the object has been modified; please apply your changes to the latest version and try again&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;apply-patch&quot;&gt;Apply Patch&lt;/h3&gt;

&lt;p&gt;Apply Patch是一种声明式的Patch方式，主要分为Server-side和Client-side两种方式。&lt;/p&gt;

&lt;h4 id=&quot;client-side-apply-patch&quot;&gt;Client Side Apply Patch&lt;/h4&gt;

&lt;p&gt;在使用kubectl apply命令时，默认会采用Client Side Apply Patch的方式，如果想切换至Server Side Apply Patch则需要指定&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--server-side=true&lt;/code&gt;。Client Side Apply Patch默认使用Strategic Merge Patch。&lt;/p&gt;

&lt;h5 id=&quot;last-applied-configuration&quot;&gt;Last Applied Configuration&lt;/h5&gt;
&lt;p&gt;kubectl apply 命令将配置文件的内容写入到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl.kubernetes.io/last-applied-configuration&lt;/code&gt; annotaion中。 这些内容用来识别配置文件中已经移除的、因而也需要从Apiserver中保存的配置中删除的字段。 用来计算要删除或设置哪些字段的步骤如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;计算要删除的字段，即在 last-applied-configuration 中存在但在 配置文件中不再存在的字段。&lt;/li&gt;
  &lt;li&gt;计算要添加或设置的字段，即在配置文件中存在但其取值与现时配置不同的字段。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于Client Side Apply Patch的使用，可以参考：&lt;a href=&quot;https://kubernetes.io/docs/tasks/manage-kubernetes-objects/declarative-config/&quot;&gt;declarative-config&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;server-side-apply-patch&quot;&gt;Server Side Apply Patch&lt;/h4&gt;

&lt;p&gt;顾名思义，Server Side Apply Patch是在server端执行apply patch操作，它适用于HTTP PATCH方法。media type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/apply-patch+yaml&lt;/code&gt;用于标识此类Patch。&lt;/p&gt;

&lt;h5 id=&quot;field-management&quot;&gt;Field Management&lt;/h5&gt;
&lt;p&gt;相对于通过Client Side Apply Patch的last-applied，Server Side Apply Patch使用了一种更具声明式特点的方法： 它持续的跟踪用户的字段管理权，而不仅仅是最后一次的执行状态。这就意味着，需要向外暴露关于用哪一个字段管理器负责管理对象中的哪个字段的这类信息。&lt;/p&gt;

&lt;p&gt;当使用Server Side Apply Patch尝试着去改变一个被其他人管理的字段，如果没有使用force参数的情况下会导致请求被拒绝。如果两个或以上的调用者均把同一个字段设置为相同值，他们将共享此字段的所有权。 后续任何改变共享字段值的尝试，不管由那个应用者发起，都会导致冲突。只需从配置文件中删除该字段即可放弃共享字段的所有权。字段管理的信息存储在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;managedFields&lt;/code&gt;字段中，该字段是对象的 metadata 中的一部分。&lt;/p&gt;

&lt;p&gt;Server Side Apply Patch创建的一个例子：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: test-cm
  namespace: default
  labels:
    test-label: test
  managedFields:
  - manager: kubectl
    operation: Apply
    apiVersion: v1
    time: &quot;2010-10-10T0:00:00Z&quot;
    fieldsType: FieldsV1
    fieldsV1:
      f:metadata:
        f:labels:
          f:test-label: {}
      f:data:
        f:key: {}
data:
  key: some value
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;conflicts&quot;&gt;Conflicts&lt;/h5&gt;

&lt;p&gt;当在执行 Apply 改变一个字段时，而恰巧该字段被其他用户声明过主权时，会导致冲突。这可以防止一个应用者不小心覆盖掉其他用户设置的值。冲突发生时，应用者有三种办法来解决它：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;覆盖前值，成为唯一的管理器：如果打算覆盖该值（或应用者是一个自动化部件，比如控制器），应用者应该设置参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;force&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;，然后再发送一次请求。这将强制操作成功，改变字段的值，从所有其他管理器的 managedFields 条目中删除该字段。&lt;/li&gt;
  &lt;li&gt;不覆盖前值，放弃管理权：如果应用者不再关注该字段的值，可以从配置文件中删掉该字段，再重新发送请求。&lt;/li&gt;
  &lt;li&gt;不覆盖前值，成为共享的管理器：如果应用者仍然关注字段值，并不想覆盖它，他们可以在配置文件中把字段的值改为和服务器对象一样，再重新发送请求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在冲突发生的时候，只有apply操作失败，而update 则不会。&lt;/li&gt;
  &lt;li&gt;apply操作必须通过提供一个 fieldManager 查询参数来标识自身， 而此查询参数对于 update 操作则是可选的。&lt;/li&gt;
  &lt;li&gt;当使用 apply 命令时，请求中的对象不能含有 managedFields字段。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;manager&quot;&gt;Manager&lt;/h5&gt;

&lt;p&gt;在apply操作中，必须指定fieldManager参数，该参数的值会赋值给managedFields.manager，同时也用来做冲突检查。对于其他操作managedFields.manager字段值通常是从user-agent中计算出来的。kubectl操作产生的manager字段为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;example&quot;&gt;Example&lt;/h5&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := []byte(`{
	&quot;apiVersion&quot;: &quot;apps/v1&quot;,
	&quot;kind&quot;: Deployment,
	&quot;metadata&quot;:{
		&quot;annotations&quot;: {
			&quot;provider-name&quot;: &quot;my-provider&quot;
		}
	}
}`)

deployment, err := clientset.AppsV1().Deployments(apiv1.NamespaceDefault).Patch(context.TODO(), &quot;my-deployment&quot;, types.ApplyPatchType, jsonPatch, metav1.PatchOptions{
	FieldManager: &quot;test-controller&quot;,
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kc get deployment my-deployment -o yaml --show-managed-fields&lt;/code&gt; 查看&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;managedFields&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;managedFields:
- apiVersion: apps/v1
  fieldsType: FieldsV1
  fieldsV1:
    f:metadata:
      f:annotations:
        f:provider-name: {}
  manager: test-controller
  operation: Apply
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可见provider-name的manager是test-controller。当使用另外一个manager对该字段更新时：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := []byte(`{
	&quot;apiVersion&quot;: &quot;apps/v1&quot;,
	&quot;kind&quot;: Deployment,
	&quot;metadata&quot;:{
		&quot;annotations&quot;: {
			&quot;provider-name&quot;: &quot;my-provider-update&quot;
		}
	}
}`)
deployment, err := clientset.AppsV1().Deployments(apiv1.NamespaceDefault).Patch(context.TODO(), &quot;my-deployment&quot;, types.ApplyPatchType, jsonPatch, metav1.PatchOptions{
	FieldManager: &quot;another-controller&quot;,
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Apiserver 返回错误&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Apply failed with 1 conflict: conflict with &quot;test-controller&quot;: .metadata.annotations.provider-name&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;optimistic-lock-1&quot;&gt;Optimistic Lock&lt;/h5&gt;
&lt;p&gt;Kubernetes Client 在Server side apply patch功能中支持乐观锁，但是需要在patch文件中指明resourceversion，例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := []byte(`{
	&quot;apiVersion&quot;: &quot;apps/v1&quot;,
	&quot;kind&quot;: Deployment,
	&quot;metadata&quot;:{
		&quot;annotations&quot;: {
			&quot;provider-name&quot;: &quot;my-provider&quot;
		},
		&quot;resourceVersion&quot;: &quot;1501414&quot;
	}
}
`)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于Client Side Apply Patch的使用，可以参考：&lt;a href=&quot;https://kubernetes.io/docs/reference/using-api/server-side-apply/&quot;&gt;server-side-apply&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;strategic-merge-patch&quot;&gt;Strategic Merge Patch&lt;/h3&gt;

&lt;p&gt;trategic Merge Patch并没有一个通用的 RFC 标准，而是Kubernetes单独定义的Patch行为，不过相比Json/Json Merge Patch而言却更为强大的。它适用于HTTP PATCH方法。media type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;application/strategic-merge-patch+json&lt;/code&gt;用于标识此类Patch。&lt;/p&gt;

&lt;p&gt;Strategic Merge Patch的行为会由Json字段上的标签决定，例如根据其Patch策略替换或合并列表。Patch策略由代码中字段标签中的patchStrategy值指定。比如PodSpec结构体的Containers字段有一个值为merge的patchStrategy:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type PodSpec struct {
  ...
  Containers []Container `json:&quot;containers&quot; patchStrategy:&quot;merge&quot; patchMergeKey:&quot;name&quot; ...`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体使用方式同Json merge patch类似，只不过其merge行为由patchStrategy控制：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := []byte(`{
  &quot;spec&quot;: {
    &quot;template&quot;: {
      &quot;spec&quot;:{
        &quot;containers&quot;: [
          {
          	&quot;name&quot;: &quot;patch-demo-ctr-2&quot;,
          	&quot;image&quot;: &quot;redis&quot;
          }
        ]        
      }
    }
  }
}`)
...
deployment, err := clientset.AppsV1().Deployments(apiv1.NamespaceDefault).Patch(context.TODO(), &quot;my-deployment&quot;, types.StrategicMergePatchType, jsonPatch, metav1.PatchOptions{})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;optimistic-lock-2&quot;&gt;Optimistic Lock&lt;/h4&gt;
&lt;p&gt;Kubernetes Client在Strategic merge patch功能中支持乐观锁，但是需要在patch文件中指明resourceversion，例如：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jsonPatch := []byte(`{
	&quot;metadata&quot;:{
		&quot;resourceVersion&quot;: &quot;1501414&quot;
	},
	&quot;spec&quot;: {
		&quot;template&quot;: {
			&quot;spec&quot;:{
				&quot;containers&quot;: [
					{
						&quot;name&quot;: &quot;patch-demo-ctr-2&quot;,
						&quot;image&quot;: &quot;redis&quot;
					}
				]        
			}
		}
	}
}
`)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于patchStrategy的使用，可以参考：&lt;a href=&quot;https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/&quot;&gt;update-api-object-kubectl-patch&lt;/a&gt;&lt;/p&gt;</content><author><name>Johan Wang</name><email>youhangwang@foxmail.com</email></author><category term="Kubernetes" /><category term="client-go" /><summary type="html">Kubernetes提供了两种更新资源的的机制: update和patch。本文将会介绍这这种方式的具体使用方法，区别和原理。</summary></entry><entry><title type="html">Container Storage Interface（CSI)</title><link href="http://localhost:4000/2021/10/29/CSI.html" rel="alternate" type="text/html" title="Container Storage Interface（CSI)" /><published>2021-10-29T00:00:00+08:00</published><updated>2021-10-29T00:00:00+08:00</updated><id>http://localhost:4000/2021/10/29/CSI</id><content type="html" xml:base="http://localhost:4000/2021/10/29/CSI.html">&lt;p&gt;CSI是一套存储产品通用的RPC接口。对于容器编排平台(CO)，支持CSI接口就意味可以支持多种存储厂商/类型；对于存储厂商，支持CSI接口就可以支持多平台，减少研发投入的同时扩宽市场。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;在正式介绍CSI之前，先对文中出现的一些专有名字或者缩写做说明。其含义如下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;词语&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Volume&lt;/td&gt;
      &lt;td&gt;通过CSI，在Container内部可使用的一个存储单元&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Block Volume&lt;/td&gt;
      &lt;td&gt;在Container内部，以Block设备形式出现的Volume&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CO&lt;/td&gt;
      &lt;td&gt;Container Orchestration System, 通过CSI RPC服务与Plugin通信&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SP&lt;/td&gt;
      &lt;td&gt;Storage Provider，一个CSI Plugin实现的厂商&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Plugin&lt;/td&gt;
      &lt;td&gt;提供CSI定义的gRPC服务&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;部署结构&quot;&gt;部署结构&lt;/h2&gt;

&lt;p&gt;CSI主要关注的是CO和Plugin之间的通信协议，它为不同的部署架构提供跨CO兼容的Plugin。下图展示了几种可能的部署方式：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                             CO &quot;Master&quot; Host
+-------------------------------------------+
|                                           |
|  +------------+           +------------+  |
|  |     CO     |   gRPC    | Controller |  |
|  |            +-----------&amp;gt;   Plugin   |  |
|  +------------+           +------------+  |
|                                           |
+-------------------------------------------+

                            CO &quot;Node&quot; Host(s)
+-------------------------------------------+
|                                           |
|  +------------+           +------------+  |
|  |     CO     |   gRPC    |    Node    |  |
|  |            +-----------&amp;gt;   Plugin   |  |
|  +------------+           +------------+  |
|                                           |
+-------------------------------------------+
Figure 1: Plugin运行在集群中的所有节点上: 一个集中式的Controller Plugin运行在CO master节点上，Node Plugin运行在所有的Node节点上。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                            CO &quot;Node&quot; Host(s)
+-------------------------------------------+
|                                           |
|  +------------+           +------------+  |
|  |     CO     |   gRPC    | Controller |  |
|  |            +--+--------&amp;gt;   Plugin   |  |
|  +------------+  |        +------------+  |
|                  |                        |
|                  |                        |
|                  |        +------------+  |
|                  |        |    Node    |  |
|                  +--------&amp;gt;   Plugin   |  |
|                           +------------+  |
|                                           |
+-------------------------------------------+
Figure 2: 只有CO Node节点运行Plugins。plugin分成两个组件，分别负责Controller Service 和 Node Service。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                            CO &quot;Node&quot; Host(s)
+-------------------------------------------+
|                                           |
|  +------------+           +------------+  |
|  |     CO     |   gRPC    | Controller |  |
|  |            +-----------&amp;gt;    Node    |  |
|  +------------+           |   Plugin   |  |
|                           +------------+  |
|                                           |
+-------------------------------------------+
Figure 3: 只有CO Node节点运行Plugins. 一个统一的Plugin组件同时支持Controller Service 和 Node Service。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                            CO &quot;Node&quot; Host(s)
+-------------------------------------------+
|                                           |
|  +------------+           +------------+  |
|  |     CO     |   gRPC    |    Node    |  |
|  |            +-----------&amp;gt;   Plugin   |  |
|  +------------+           +------------+  |
|                                           |
+-------------------------------------------+
Figure 4: 只有CO Node节点运行Plugins. Plugin组件只支持Node Service。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Plugin主要包括两个部分：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Controller Plugin：主要用来提供Controller Service&lt;/li&gt;
  &lt;li&gt;Node Plugin：主要用来提供Node Service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在某些情况，plugin可以只包含Node Plugin，如Figure 4所示。但如无必要，两种组件都要实现。&lt;/p&gt;

&lt;h2 id=&quot;volume-lifecycle&quot;&gt;Volume LifeCycle&lt;/h2&gt;

&lt;p&gt;下面是几种CO通过CSI管理Volume生命周期的示意图。Plugin支持的功能可以从ControllerGetCapabilities和NodeGetCapabilities这两个RPC接口中获取。不支持的RPC接口应该返回一个适当的错误码(CALL_NOT_IMPLEMENTED)通知调用方。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   CreateVolume +------------+ DeleteVolume
 +-------------&amp;gt;|  CREATED   +--------------+
 |              +---+----^---+              |
 |       Controller |    | Controller       v
+++         Publish |    | Unpublish       +++
|X|          Volume |    | Volume          | |
+-+             +---v----+---+             +-+
                | NODE_READY |
                +---+----^---+
               Node |    | Node
            Publish |    | Unpublish
             Volume |    | Volume
                +---v----+---+
                | PUBLISHED  |
                +------------+

Figure 5: 一个动态provisioned volume从创建到销毁的生命周期。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   CreateVolume +------------+ DeleteVolume
 +-------------&amp;gt;|  CREATED   +--------------+
 |              +---+----^---+              |
 |       Controller |    | Controller       v
+++         Publish |    | Unpublish       +++
|X|          Volume |    | Volume          | |
+-+             +---v----+---+             +-+
                | NODE_READY |
                +---+----^---+
               Node |    | Node
              Stage |    | Unstage
             Volume |    | Volume
                +---v----+---+
                |  VOL_READY |
                +---+----^---+
               Node |    | Node
            Publish |    | Unpublish
             Volume |    | Volume
                +---v----+---+
                | PUBLISHED  |
                +------------+

Figure 6: 当Node plugin具有STAGE_UNSTAGE_VOLUME能力时，一个动态provisioned volume从创建到销毁的生命周期。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Controller                  Controller
       Publish                  Unpublish
        Volume  +------------+  Volume
 +-------------&amp;gt;+ NODE_READY +--------------+
 |              +---+----^---+              |
 |             Node |    | Node             v
+++         Publish |    | Unpublish       +++
|X| &amp;lt;-+      Volume |    | Volume          | |
+++   |         +---v----+---+             +-+
 |    |         | PUBLISHED  |
 |    |         +------------+
 +----+
   Validate
   Volume
   Capabilities

Figure 7: 一个Pre-provisioned volume的生命周期。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;       +-+  +-+
       |X|  | |
       +++  +^+
        |    |
   Node |    | Node
Publish |    | Unpublish
 Volume |    | Volume
    +---v----+---+
    | PUBLISHED  |
    +------------+

Figure 8: Plugins通过capabilities API可以放弃其他的lifecycle steps，只留下`NodePublishVolume`和`NodeUnpublishVolume`两个步骤。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;rpc-interface&quot;&gt;RPC Interface&lt;/h2&gt;

&lt;p&gt;CO通过RPC接口同Plugin通信，每个Storage Provider必须提供:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Node Plugin: RPC server，必须运行在将要publish provisioned volume的节点上。&lt;/li&gt;
  &lt;li&gt;Controller Plugin: gRPC server，可以运行在任何位置。&lt;/li&gt;
  &lt;li&gt;在一些情况下，一个plugin组件可以同时提供Node和Controller两种service。（Figure 3 in &lt;a href=&quot;#部署结构&quot;&gt;部署结构&lt;/a&gt;）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;RPC接口可以分为三类：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Identity Service: Node和Controller Plugin都必须提供此类RPC接口&lt;/li&gt;
  &lt;li&gt;Controller Service: Controller Plugin必须提供此类RPC接口&lt;/li&gt;
  &lt;li&gt;Node Service: Node Plugin必须提供提供此类RPC接口&lt;/li&gt;
&lt;/ol&gt;

&lt;details&gt;
  &lt;summary&gt;点开查看Plugin RPC接口列表&lt;/summary&gt;
  &lt;pre&gt;&lt;code&gt;
service Identity {
  rpc GetPluginInfo(GetPluginInfoRequest)
    returns (GetPluginInfoResponse) {}

  rpc GetPluginCapabilities(GetPluginCapabilitiesRequest)
    returns (GetPluginCapabilitiesResponse) {}

  rpc Probe (ProbeRequest)
    returns (ProbeResponse) {}
}

service Controller {
  rpc CreateVolume (CreateVolumeRequest)
    returns (CreateVolumeResponse) {}

  rpc DeleteVolume (DeleteVolumeRequest)
    returns (DeleteVolumeResponse) {}

  rpc ControllerPublishVolume (ControllerPublishVolumeRequest)
    returns (ControllerPublishVolumeResponse) {}

  rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)
    returns (ControllerUnpublishVolumeResponse) {}

  rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest)
    returns (ValidateVolumeCapabilitiesResponse) {}

  rpc ListVolumes (ListVolumesRequest)
    returns (ListVolumesResponse) {}

  rpc GetCapacity (GetCapacityRequest)
    returns (GetCapacityResponse) {}

  rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest)
    returns (ControllerGetCapabilitiesResponse) {}

  rpc CreateSnapshot (CreateSnapshotRequest)
    returns (CreateSnapshotResponse) {}

  rpc DeleteSnapshot (DeleteSnapshotRequest)
    returns (DeleteSnapshotResponse) {}

  rpc ListSnapshots (ListSnapshotsRequest)
    returns (ListSnapshotsResponse) {}

  rpc ControllerExpandVolume (ControllerExpandVolumeRequest)
    returns (ControllerExpandVolumeResponse) {}

  rpc ControllerGetVolume (ControllerGetVolumeRequest)
    returns (ControllerGetVolumeResponse) {
        option (alpha_method) = true;
    }
}

service Node {
  rpc NodeStageVolume (NodeStageVolumeRequest)
    returns (NodeStageVolumeResponse) {}

  rpc NodeUnstageVolume (NodeUnstageVolumeRequest)
    returns (NodeUnstageVolumeResponse) {}

  rpc NodePublishVolume (NodePublishVolumeRequest)
    returns (NodePublishVolumeResponse) {}

  rpc NodeUnpublishVolume (NodeUnpublishVolumeRequest)
    returns (NodeUnpublishVolumeResponse) {}

  rpc NodeGetVolumeStats (NodeGetVolumeStatsRequest)
    returns (NodeGetVolumeStatsResponse) {}

  rpc NodeExpandVolume(NodeExpandVolumeRequest)
    returns (NodeExpandVolumeResponse) {}

  rpc NodeGetCapabilities (NodeGetCapabilitiesRequest)
    returns (NodeGetCapabilitiesResponse) {}

  rpc NodeGetInfo (NodeGetInfoRequest)
    returns (NodeGetInfoResponse) {}
}
  &lt;/code&gt;&lt;/pre&gt;
&lt;/details&gt;

&lt;h3 id=&quot;并发性&quot;&gt;并发性&lt;/h3&gt;

&lt;p&gt;通常，在给定时间内，CO需负责确保每个Volume的“进行中”调用不超过一个。但是在某些情况下CO可能会丢失掉状态信息（比如CO崩溃或者重启），此时CO有可能会对同一Volume同时发起多个调用，Plugin应该尽可能优雅的处理该情况，例如返回错误码&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ABORTED&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;超时与重试&quot;&gt;超时与重试&lt;/h3&gt;

&lt;p&gt;RPC的调用可能超时或者失败。由CO决定超时时间的长短，重试时间的间隔和重试的次数。CSI接口的实现要求幂等，这样可以确保具有相同字段的重试调用在重试时从中断处继续处理。取消调用的唯一方法是发出“否定”调用（如果存在）。例如，发出ControllerUnpublishVolume调用以取消挂起的ControllerPublishVolume操作。在某些情况下，CO可能无法取消挂起的操作，因为它取决于挂起操作的结果以执行“否定”调用。例如，如果 CreateVolume调用永远不会完成，那么CO就会获取不到用于调用DeleteVolume的volume_id。&lt;/p&gt;

&lt;h3 id=&quot;secrets&quot;&gt;Secrets&lt;/h3&gt;

&lt;p&gt;调用Plugin的RPC可能需要传入Secrets，一个Secret是一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map[string]string&lt;/code&gt;，其中key用来指定secret的名字（username或者password），value包含secret数据。SP应该在文档中公布其要求的secret格式。CO会携带该secret发起调用，其中CO可能会在所有的RPC调用中传入相同的secret，因此SP需要的key值在CSI操作中必须是唯一的。&lt;/p&gt;

&lt;h3 id=&quot;identity-service-rpc&quot;&gt;Identity Service RPC&lt;/h3&gt;

&lt;p&gt;Identity Service允许CO查询一个plugin所具有的功能，健康状态和其他的一些元数据。所有接口返回的错误消息内容与格式不在文中阐述，如有需要，可以参考&lt;a href=&quot;https://github.com/container-storage-interface/spec/blob/master/spec.md&quot;&gt;CSI Spec&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;getplugininfo&quot;&gt;GetPluginInfo&lt;/h4&gt;
&lt;p&gt;调用该RPC接口可以获取Plugin的名字，版本号和一些其他相关信息。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message GetPluginInfoRequest {
  // Intentionally empty.
}
message GetPluginInfoResponse {
  // This field is REQUIRED.
  string name = 1;

  // This field is REQUIRED. Value of this field is opaque to the CO.
  string vendor_version = 2;

  // This field is OPTIONAL. Values are opaque to the CO.
  map&amp;lt;string, string&amp;gt; manifest = 3;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;getplugincapabilities&quot;&gt;GetPluginCapabilities&lt;/h4&gt;
&lt;p&gt;该RPC允许CO查询Plugin整体所支持的功能：它是Plugin的所有实例的所有功能的总和。无论Plugin实例部署在集群上的哪些位置还是Plugin实例服务于哪些RPC接口，相同版本的所有Plugin实例（请参阅 GetPluginInfoResponse 的 vendor_version）都应返回相同的功能集合。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message GetPluginCapabilitiesRequest {
  // Intentionally empty.
}

message GetPluginCapabilitiesResponse {
  // All the capabilities that the controller service supports. This field is OPTIONAL.
  repeated PluginCapability capabilities = 1;
}

// Specifies a capability of the plugin.
message PluginCapability {
  message Service {
    enum Type {
      UNKNOWN = 0;
      // CONTROLLER_SERVICE indicates that the Plugin provides RPCs for
      // the ControllerService. Plugins SHOULD provide this capability.
      // In rare cases certain plugins MAY wish to omit the
      // ControllerService entirely from their implementation, but such
      // SHOULD NOT be the common case.
      // The presence of this capability determines whether the CO will
      // attempt to invoke the REQUIRED ControllerService RPCs, as well
      // as specific RPCs as indicated by ControllerGetCapabilities.
      CONTROLLER_SERVICE = 1;

      // VOLUME_ACCESSIBILITY_CONSTRAINTS indicates that the volumes for
      // this plugin MAY NOT be equally accessible by all nodes in the
      // cluster. The CO MUST use the topology information returned by
      // CreateVolumeRequest along with the topology information
      // returned by NodeGetInfo to ensure that a given volume is
      // accessible from a given node when scheduling workloads.
      VOLUME_ACCESSIBILITY_CONSTRAINTS = 2;
    }
    Type type = 1;
  }

  message VolumeExpansion {
    enum Type {
      UNKNOWN = 0;

      // ONLINE indicates that volumes may be expanded when published to
      // a node. When a Plugin implements this capability it MUST
      // implement either the EXPAND_VOLUME controller capability or the
      // EXPAND_VOLUME node capability or both. When a plugin supports
      // ONLINE volume expansion and also has the EXPAND_VOLUME
      // controller capability then the plugin MUST support expansion of
      // volumes currently published and available on a node. When a
      // plugin supports ONLINE volume expansion and also has the
      // EXPAND_VOLUME node capability then the plugin MAY support
      // expansion of node-published volume via NodeExpandVolume.
      //
      // Example 1: Given a shared filesystem volume (e.g. GlusterFs),
      //   the Plugin may set the ONLINE volume expansion capability and
      //   implement ControllerExpandVolume but not NodeExpandVolume.
      //
      // Example 2: Given a block storage volume type (e.g. EBS), the
      //   Plugin may set the ONLINE volume expansion capability and
      //   implement both ControllerExpandVolume and NodeExpandVolume.
      //
      // Example 3: Given a Plugin that supports volume expansion only
      //   upon a node, the Plugin may set the ONLINE volume
      //   expansion capability and implement NodeExpandVolume but not
      //   ControllerExpandVolume.
      ONLINE = 1;

      // OFFLINE indicates that volumes currently published and
      // available on a node SHALL NOT be expanded via
      // ControllerExpandVolume. When a plugin supports OFFLINE volume
      // expansion it MUST implement either the EXPAND_VOLUME controller
      // capability or both the EXPAND_VOLUME controller capability and
      // the EXPAND_VOLUME node capability.
      //
      // Example 1: Given a block storage volume type (e.g. Azure Disk)
      //   that does not support expansion of &quot;node-attached&quot; (i.e.
      //   controller-published) volumes, the Plugin may indicate
      //   OFFLINE volume expansion support and implement both
      //   ControllerExpandVolume and NodeExpandVolume.
      OFFLINE = 2;
    }
    Type type = 1;
  }

  oneof type {
    // Service that the plugin supports.
    Service service = 1;
    VolumeExpansion volume_expansion = 2;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;probe&quot;&gt;Probe&lt;/h4&gt;
&lt;p&gt;该接口的主要目的就是验证Plugin的状态是否健康。如果状态为不健康，CO会采取一些操作以尝试将plugin的状态恢复至健康状态，可能的操作包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;重启plugin容器&lt;/li&gt;
  &lt;li&gt;通知plugin管理员&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CO可以在任何时刻以任意次数调用该RPC接口，但此类重复调用可能会产生资源开销。 SP应在文档中说明有关调用此接口的指南和已知限制。例如，SP可以记录应该调用它的Probe接口的最大频率。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message ProbeRequest {
  // Intentionally empty.
}

message ProbeResponse {
  // Readiness allows a plugin to report its initialization status back
  // to the CO. Initialization for some plugins MAY be time consuming
  // and it is important for a CO to distinguish between the following
  // cases:
  //
  // 1) The plugin is in an unhealthy state and MAY need restarting. In
  //    this case a gRPC error code SHALL be returned.
  // 2) The plugin is still initializing, but is otherwise perfectly
  //    healthy. In this case a successful response SHALL be returned
  //    with a readiness value of `false`. Calls to the plugin&apos;s
  //    Controller and/or Node services MAY fail due to an incomplete
  //    initialization state.
  // 3) The plugin has finished initializing and is ready to service
  //    calls to its Controller and/or Node services. A successful
  //    response is returned with a readiness value of `true`.
  //
  // This field is OPTIONAL. If not present, the caller SHALL assume
  // that the plugin is in a ready state and is accepting calls to its
  // Controller and/or Node services (according to the plugin&apos;s reported
  // capabilities).
  .google.protobuf.BoolValue ready = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;controller-service-rpc&quot;&gt;Controller Service RPC&lt;/h3&gt;

&lt;p&gt;Controller Service RPC是Controller Plugin需要向外暴露的接口。&lt;/p&gt;

&lt;h4 id=&quot;controllergetcapabilities&quot;&gt;ControllerGetCapabilities&lt;/h4&gt;

&lt;p&gt;Controller Plugin必须实现此接口，该接口允许CO检查Controller Plugin所支持的功能。&lt;/p&gt;

&lt;p&gt;各类功能和RPC接口的对应关系见下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Cpability&lt;/th&gt;
      &lt;th&gt;RPCs&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;MUST_IMPLEMENT&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ValidateVolumeCapabilities&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerGetCapabilities&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CREATE_DELETE_VOLUME&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateVolume&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DeleteVolume&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LIST_VOLUMES&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListVolumes&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GET_VOLUME&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerGetVolume&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CLONE_VOLUME&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateVolume&lt;/code&gt; from volume&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SINGLE_NODE_MULTI_WRITER&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateVolume&lt;/code&gt; with SINGLE_NODE_SINGLE_WRITER and/or SINGLE_NODE_MULTI_WRITER access modes.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LIST_VOLUMES_PUBLISHED_NODES&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListVolumes&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerGetVolume&lt;/code&gt; return published_node_ids&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VOLUME_CONDITION&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerGetVolume&lt;/code&gt; return non-nil volume_condition&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CREATE_DELETE_SNAPSHOT&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CreateSnapshot&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DeleteSnapshot&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LIST_SNAPSHOTS&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ListSnapshots&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PUBLISH_UNPUBLISH_VOLUME&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerPublishVolume&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerUnpublishVolume&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeGetInfo&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PUBLISH_READONLY&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerPublishVolume&lt;/code&gt; with readonly mode&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GET_CAPACITY&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetCapacity&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EXPAND_VOLUME&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerExpandVolume&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message ControllerGetCapabilitiesRequest {
  // Intentionally empty.
}

message ControllerGetCapabilitiesResponse {
  // All the capabilities that the controller service supports. This
  // field is OPTIONAL.
  repeated ControllerServiceCapability capabilities = 1;
}

// Specifies a capability of the controller service.
message ControllerServiceCapability {
  message RPC {
    enum Type {
      UNKNOWN = 0;
      CREATE_DELETE_VOLUME = 1;
      PUBLISH_UNPUBLISH_VOLUME = 2;
      LIST_VOLUMES = 3;
      GET_CAPACITY = 4;
      // Currently the only way to consume a snapshot is to create
      // a volume from it. Therefore plugins supporting
      // CREATE_DELETE_SNAPSHOT MUST support creating volume from
      // snapshot.
      CREATE_DELETE_SNAPSHOT = 5;
      LIST_SNAPSHOTS = 6;

      // Plugins supporting volume cloning at the storage level MAY
      // report this capability. The source volume MUST be managed by
      // the same plugin. Not all volume sources and parameters
      // combinations MAY work.
      CLONE_VOLUME = 7;

      // Indicates the SP supports ControllerPublishVolume.readonly
      // field.
      PUBLISH_READONLY = 8;

      // See VolumeExpansion for details.
      EXPAND_VOLUME = 9;

      // Indicates the SP supports the
      // ListVolumesResponse.entry.published_node_ids field and the
      // ControllerGetVolumeResponse.published_node_ids field.
      // The SP MUST also support PUBLISH_UNPUBLISH_VOLUME.
      LIST_VOLUMES_PUBLISHED_NODES = 10;

      // Indicates that the Controller service can report volume
      // conditions.
      // An SP MAY implement `VolumeCondition` in only the Controller
      // Plugin, only the Node Plugin, or both.
      // If `VolumeCondition` is implemented in both the Controller and
      // Node Plugins, it SHALL report from different perspectives.
      // If for some reason Controller and Node Plugins report
      // misaligned volume conditions, CO SHALL assume the worst case
      // is the truth.
      // Note that, for alpha, `VolumeCondition` is intended be
      // informative for humans only, not for automation.
      VOLUME_CONDITION = 11 [(alpha_enum_value) = true];

      // Indicates the SP supports the ControllerGetVolume RPC.
      // This enables COs to, for example, fetch per volume
      // condition after a volume is provisioned.
      GET_VOLUME = 12 [(alpha_enum_value) = true];

      // Indicates the SP supports the SINGLE_NODE_SINGLE_WRITER and/or
      // SINGLE_NODE_MULTI_WRITER access modes.
      // These access modes are intended to replace the
      // SINGLE_NODE_WRITER access mode to clarify the number of writers
      // for a volume on a single node. Plugins MUST accept and allow
      // use of the SINGLE_NODE_WRITER access mode when either
      // SINGLE_NODE_SINGLE_WRITER and/or SINGLE_NODE_MULTI_WRITER are
      // supported, in order to permit older COs to continue working.
      SINGLE_NODE_MULTI_WRITER = 13 [(alpha_enum_value) = true];
    }

    Type type = 1;
  }

  oneof type {
    // RPC that the controller supports.
    RPC rpc = 1;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;createvolume&quot;&gt;CreateVolume&lt;/h4&gt;
&lt;p&gt;CO会调用CreateVolume接口provision一个Volume。此接口必须是幂等的，假如已经存在同名的volume，并且属性兼容于创建的请求，则plugin需返回OK。&lt;/p&gt;

&lt;p&gt;Plugin可以创建三种volume：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;空的volume。&lt;/li&gt;
  &lt;li&gt;从snapshot中创建volume，但是plugin需支持&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CREATE_DELETE_SNAPSHOT&lt;/code&gt;的功能。&lt;/li&gt;
  &lt;li&gt;从一个已有的volume中创建volume，plugin需要额外支持&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLONE_VOLUME&lt;/code&gt;的功能。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果CO请求从现有的Snapshot或Volume创建Volume，并且请求的Volume大小大于原始Snapshot（或克隆Volume），则Plugin可以拒绝此类调用并返回带有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OUT_OF_RANGE&lt;/code&gt;错误，或者当此volume通过NodePublish调用呈现给工作负载时，必须提供一个具有有请求的大小并包含来自Snapshot（或原始Volume）的数据的volume。如果Volume具有MountVolume的VolumeCapability访问类型并且需要调整文件系统大小以提供请求的容量，则Plugin需要在 NodePublish 调用时（或之前）调整新创建Volume的文件系统大小。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message CreateVolumeRequest {
  // The suggested name for the storage space. This field is REQUIRED.
  // It serves two purposes:
  // 1) Idempotency - This name is generated by the CO to achieve
  //    idempotency.  The Plugin SHOULD ensure that multiple
  //    `CreateVolume` calls for the same name do not result in more
  //    than one piece of storage provisioned corresponding to that
  //    name. If a Plugin is unable to enforce idempotency, the CO&apos;s
  //    error recovery logic could result in multiple (unused) volumes
  //    being provisioned.
  //    In the case of error, the CO MUST handle the gRPC error codes
  //    per the recovery behavior defined in the &quot;CreateVolume Errors&quot;
  //    section below.
  //    The CO is responsible for cleaning up volumes it provisioned
  //    that it no longer needs. If the CO is uncertain whether a volume
  //    was provisioned or not when a `CreateVolume` call fails, the CO
  //    MAY call `CreateVolume` again, with the same name, to ensure the
  //    volume exists and to retrieve the volume&apos;s `volume_id` (unless
  //    otherwise prohibited by &quot;CreateVolume Errors&quot;).
  // 2) Suggested name - Some storage systems allow callers to specify
  //    an identifier by which to refer to the newly provisioned
  //    storage. If a storage system supports this, it can optionally
  //    use this name as the identifier for the new volume.
  // Any Unicode string that conforms to the length limit is allowed
  // except those containing the following banned characters:
  // U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
  // (These are control characters other than commonly used whitespace.)
  string name = 1;

  // This field is OPTIONAL. This allows the CO to specify the capacity
  // requirement of the volume to be provisioned. If not specified, the
  // Plugin MAY choose an implementation-defined capacity range. If
  // specified it MUST always be honored, even when creating volumes
  // from a source; which MAY force some backends to internally extend
  // the volume after creating it.
  CapacityRange capacity_range = 2;

  // The capabilities that the provisioned volume MUST have. SP MUST
  // provision a volume that will satisfy ALL of the capabilities
  // specified in this list. Otherwise SP MUST return the appropriate
  // gRPC error code.
  // The Plugin MUST assume that the CO MAY use the provisioned volume
  // with ANY of the capabilities specified in this list.
  // For example, a CO MAY specify two volume capabilities: one with
  // access mode SINGLE_NODE_WRITER and another with access mode
  // MULTI_NODE_READER_ONLY. In this case, the SP MUST verify that the
  // provisioned volume can be used in either mode.
  // This also enables the CO to do early validation: If ANY of the
  // specified volume capabilities are not supported by the SP, the call
  // MUST return the appropriate gRPC error code.
  // This field is REQUIRED.
  repeated VolumeCapability volume_capabilities = 3;

  // Plugin specific parameters passed in as opaque key-value pairs.
  // This field is OPTIONAL. The Plugin is responsible for parsing and
  // validating these parameters. COs will treat these as opaque.
  map&amp;lt;string, string&amp;gt; parameters = 4;

  // Secrets required by plugin to complete volume creation request.
  // This field is OPTIONAL. Refer to the `Secrets Requirements`
  // section on how to use this field.
  map&amp;lt;string, string&amp;gt; secrets = 5 [(csi_secret) = true];

  // If specified, the new volume will be pre-populated with data from
  // this source. This field is OPTIONAL.
  VolumeContentSource volume_content_source = 6;

  // Specifies where (regions, zones, racks, etc.) the provisioned
  // volume MUST be accessible from.
  // An SP SHALL advertise the requirements for topological
  // accessibility information in documentation. COs SHALL only specify
  // topological accessibility information supported by the SP.
  // This field is OPTIONAL.
  // This field SHALL NOT be specified unless the SP has the
  // VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
  // If this field is not specified and the SP has the
  // VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability, the SP MAY
  // choose where the provisioned volume is accessible from.
  TopologyRequirement accessibility_requirements = 7;
}

// Specifies what source the volume will be created from. One of the
// type fields MUST be specified.
message VolumeContentSource {
  message SnapshotSource {
    // Contains identity information for the existing source snapshot.
    // This field is REQUIRED. Plugin is REQUIRED to support creating
    // volume from snapshot if it supports the capability
    // CREATE_DELETE_SNAPSHOT.
    string snapshot_id = 1;
  }

  message VolumeSource {
    // Contains identity information for the existing source volume.
    // This field is REQUIRED. Plugins reporting CLONE_VOLUME
    // capability MUST support creating a volume from another volume.
    string volume_id = 1;
  }

  oneof type {
    SnapshotSource snapshot = 1;
    VolumeSource volume = 2;
  }
}

message CreateVolumeResponse {
  // Contains all attributes of the newly created volume that are
  // relevant to the CO along with information required by the Plugin
  // to uniquely identify the volume. This field is REQUIRED.
  Volume volume = 1;
}

// Specify a capability of a volume.
message VolumeCapability {
  // Indicate that the volume will be accessed via the block device API.
  message BlockVolume {
    // Intentionally empty, for now.
  }

  // Indicate that the volume will be accessed via the filesystem API.
  message MountVolume {
    // The filesystem type. This field is OPTIONAL.
    // An empty string is equal to an unspecified field value.
    string fs_type = 1;

    // The mount options that can be used for the volume. This field is
    // OPTIONAL. `mount_flags` MAY contain sensitive information.
    // Therefore, the CO and the Plugin MUST NOT leak this information
    // to untrusted entities. The total size of this repeated field
    // SHALL NOT exceed 4 KiB.
    repeated string mount_flags = 2;

    // If SP has VOLUME_MOUNT_GROUP node capability and CO provides
    // this field then SP MUST ensure that the volume_mount_group
    // parameter is passed as the group identifier to the underlying
    // operating system mount system call, with the understanding
    // that the set of available mount call parameters and/or
    // mount implementations may vary across operating systems.
    // Additionally, new file and/or directory entries written to
    // the underlying filesystem SHOULD be permission-labeled in such a
    // manner, unless otherwise modified by a workload, that they are
    // both readable and writable by said mount group identifier.
    // This is an OPTIONAL field.
    string volume_mount_group = 3 [(alpha_field) = true];
  }

  // Specify how a volume can be accessed.
  message AccessMode {
    enum Mode {
      UNKNOWN = 0;

      // Can only be published once as read/write on a single node, at
      // any given time.
      SINGLE_NODE_WRITER = 1;

      // Can only be published once as readonly on a single node, at
      // any given time.
      SINGLE_NODE_READER_ONLY = 2;

      // Can be published as readonly at multiple nodes simultaneously.
      MULTI_NODE_READER_ONLY = 3;

      // Can be published at multiple nodes simultaneously. Only one of
      // the node can be used as read/write. The rest will be readonly.
      MULTI_NODE_SINGLE_WRITER = 4;

      // Can be published as read/write at multiple nodes
      // simultaneously.
      MULTI_NODE_MULTI_WRITER = 5;

      // Can only be published once as read/write at a single workload
      // on a single node, at any given time. SHOULD be used instead of
      // SINGLE_NODE_WRITER for COs using the experimental
      // SINGLE_NODE_MULTI_WRITER capability.
      SINGLE_NODE_SINGLE_WRITER = 6 [(alpha_enum_value) = true];

      // Can be published as read/write at multiple workloads on a
      // single node simultaneously. SHOULD be used instead of
      // SINGLE_NODE_WRITER for COs using the experimental
      // SINGLE_NODE_MULTI_WRITER capability.
      SINGLE_NODE_MULTI_WRITER = 7 [(alpha_enum_value) = true];
    }

    // This field is REQUIRED.
    Mode mode = 1;
  }

  // Specifies what API the volume will be accessed using. One of the
  // following fields MUST be specified.
  oneof access_type {
    BlockVolume block = 1;
    MountVolume mount = 2;
  }

  // This is a REQUIRED field.
  AccessMode access_mode = 3;
}

// The capacity of the storage space in bytes. To specify an exact size,
// `required_bytes` and `limit_bytes` SHALL be set to the same value. At
// least one of the these fields MUST be specified.
message CapacityRange {
  // Volume MUST be at least this big. This field is OPTIONAL.
  // A value of 0 is equal to an unspecified field value.
  // The value of this field MUST NOT be negative.
  int64 required_bytes = 1;

  // Volume MUST not be bigger than this. This field is OPTIONAL.
  // A value of 0 is equal to an unspecified field value.
  // The value of this field MUST NOT be negative.
  int64 limit_bytes = 2;
}

// Information about a specific volume.
message Volume {
  // The capacity of the volume in bytes. This field is OPTIONAL. If not
  // set (value of 0), it indicates that the capacity of the volume is
  // unknown (e.g., NFS share).
  // The value of this field MUST NOT be negative.
  int64 capacity_bytes = 1;

  // The identifier for this volume, generated by the plugin.
  // This field is REQUIRED.
  // This field MUST contain enough information to uniquely identify
  // this specific volume vs all other volumes supported by this plugin.
  // This field SHALL be used by the CO in subsequent calls to refer to
  // this volume.
  // The SP is NOT responsible for global uniqueness of volume_id across
  // multiple SPs.
  string volume_id = 2;

  // Opaque static properties of the volume. SP MAY use this field to
  // ensure subsequent volume validation and publishing calls have
  // contextual information.
  // The contents of this field SHALL be opaque to a CO.
  // The contents of this field SHALL NOT be mutable.
  // The contents of this field SHALL be safe for the CO to cache.
  // The contents of this field SHOULD NOT contain sensitive
  // information.
  // The contents of this field SHOULD NOT be used for uniquely
  // identifying a volume. The `volume_id` alone SHOULD be sufficient to
  // identify the volume.
  // A volume uniquely identified by `volume_id` SHALL always report the
  // same volume_context.
  // This field is OPTIONAL and when present MUST be passed to volume
  // validation and publishing calls.
  map&amp;lt;string, string&amp;gt; volume_context = 3;

  // If specified, indicates that the volume is not empty and is
  // pre-populated with data from the specified source.
  // This field is OPTIONAL.
  VolumeContentSource content_source = 4;

  // Specifies where (regions, zones, racks, etc.) the provisioned
  // volume is accessible from.
  // A plugin that returns this field MUST also set the
  // VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
  // An SP MAY specify multiple topologies to indicate the volume is
  // accessible from multiple locations.
  // COs MAY use this information along with the topology information
  // returned by NodeGetInfo to ensure that a given volume is accessible
  // from a given node when scheduling workloads.
  // This field is OPTIONAL. If it is not specified, the CO MAY assume
  // the volume is equally accessible from all nodes in the cluster and
  // MAY schedule workloads referencing the volume on any available
  // node.
  //
  // Example 1:
  //   accessible_topology = {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;}
  // Indicates a volume accessible only from the &quot;region&quot; &quot;R1&quot; and the
  // &quot;zone&quot; &quot;Z2&quot;.
  //
  // Example 2:
  //   accessible_topology =
  //     {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;},
  //     {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z3&quot;}
  // Indicates a volume accessible from both &quot;zone&quot; &quot;Z2&quot; and &quot;zone&quot; &quot;Z3&quot;
  // in the &quot;region&quot; &quot;R1&quot;.
  repeated Topology accessible_topology = 5;
}

message TopologyRequirement {
  // Specifies the list of topologies the provisioned volume MUST be
  // accessible from.
  // This field is OPTIONAL. If TopologyRequirement is specified either
  // requisite or preferred or both MUST be specified.
  //
  // If requisite is specified, the provisioned volume MUST be
  // accessible from at least one of the requisite topologies.
  //
  // Given
  //   x = number of topologies provisioned volume is accessible from
  //   n = number of requisite topologies
  // The CO MUST ensure n &amp;gt;= 1. The SP MUST ensure x &amp;gt;= 1
  // If x==n, then the SP MUST make the provisioned volume available to
  // all topologies from the list of requisite topologies. If it is
  // unable to do so, the SP MUST fail the CreateVolume call.
  // For example, if a volume should be accessible from a single zone,
  // and requisite =
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;}
  // then the provisioned volume MUST be accessible from the &quot;region&quot;
  // &quot;R1&quot; and the &quot;zone&quot; &quot;Z2&quot;.
  // Similarly, if a volume should be accessible from two zones, and
  // requisite =
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z3&quot;}
  // then the provisioned volume MUST be accessible from the &quot;region&quot;
  // &quot;R1&quot; and both &quot;zone&quot; &quot;Z2&quot; and &quot;zone&quot; &quot;Z3&quot;.
  //
  // If x&amp;lt;n, then the SP SHALL choose x unique topologies from the list
  // of requisite topologies. If it is unable to do so, the SP MUST fail
  // the CreateVolume call.
  // For example, if a volume should be accessible from a single zone,
  // and requisite =
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z3&quot;}
  // then the SP may choose to make the provisioned volume available in
  // either the &quot;zone&quot; &quot;Z2&quot; or the &quot;zone&quot; &quot;Z3&quot; in the &quot;region&quot; &quot;R1&quot;.
  // Similarly, if a volume should be accessible from two zones, and
  // requisite =
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z3&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z4&quot;}
  // then the provisioned volume MUST be accessible from any combination
  // of two unique topologies: e.g. &quot;R1/Z2&quot; and &quot;R1/Z3&quot;, or &quot;R1/Z2&quot; and
  //  &quot;R1/Z4&quot;, or &quot;R1/Z3&quot; and &quot;R1/Z4&quot;.
  //
  // If x&amp;gt;n, then the SP MUST make the provisioned volume available from
  // all topologies from the list of requisite topologies and MAY choose
  // the remaining x-n unique topologies from the list of all possible
  // topologies. If it is unable to do so, the SP MUST fail the
  // CreateVolume call.
  // For example, if a volume should be accessible from two zones, and
  // requisite =
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;}
  // then the provisioned volume MUST be accessible from the &quot;region&quot;
  // &quot;R1&quot; and the &quot;zone&quot; &quot;Z2&quot; and the SP may select the second zone
  // independently, e.g. &quot;R1/Z4&quot;.
  repeated Topology requisite = 1;

  // Specifies the list of topologies the CO would prefer the volume to
  // be provisioned in.
  //
  // This field is OPTIONAL. If TopologyRequirement is specified either
  // requisite or preferred or both MUST be specified.
  //
  // An SP MUST attempt to make the provisioned volume available using
  // the preferred topologies in order from first to last.
  //
  // If requisite is specified, all topologies in preferred list MUST
  // also be present in the list of requisite topologies.
  //
  // If the SP is unable to to make the provisioned volume available
  // from any of the preferred topologies, the SP MAY choose a topology
  // from the list of requisite topologies.
  // If the list of requisite topologies is not specified, then the SP
  // MAY choose from the list of all possible topologies.
  // If the list of requisite topologies is specified and the SP is
  // unable to to make the provisioned volume available from any of the
  // requisite topologies it MUST fail the CreateVolume call.
  //
  // Example 1:
  // Given a volume should be accessible from a single zone, and
  // requisite =
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z3&quot;}
  // preferred =
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z3&quot;}
  // then the the SP SHOULD first attempt to make the provisioned volume
  // available from &quot;zone&quot; &quot;Z3&quot; in the &quot;region&quot; &quot;R1&quot; and fall back to
  // &quot;zone&quot; &quot;Z2&quot; in the &quot;region&quot; &quot;R1&quot; if that is not possible.
  //
  // Example 2:
  // Given a volume should be accessible from a single zone, and
  // requisite =
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z3&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z4&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z5&quot;}
  // preferred =
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z4&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;}
  // then the the SP SHOULD first attempt to make the provisioned volume
  // accessible from &quot;zone&quot; &quot;Z4&quot; in the &quot;region&quot; &quot;R1&quot; and fall back to
  // &quot;zone&quot; &quot;Z2&quot; in the &quot;region&quot; &quot;R1&quot; if that is not possible. If that
  // is not possible, the SP may choose between either the &quot;zone&quot;
  // &quot;Z3&quot; or &quot;Z5&quot; in the &quot;region&quot; &quot;R1&quot;.
  //
  // Example 3:
  // Given a volume should be accessible from TWO zones (because an
  // opaque parameter in CreateVolumeRequest, for example, specifies
  // the volume is accessible from two zones, aka synchronously
  // replicated), and
  // requisite =
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z3&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z4&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z5&quot;}
  // preferred =
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z5&quot;},
  //   {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z3&quot;}
  // then the the SP SHOULD first attempt to make the provisioned volume
  // accessible from the combination of the two &quot;zones&quot; &quot;Z5&quot; and &quot;Z3&quot; in
  // the &quot;region&quot; &quot;R1&quot;. If that&apos;s not possible, it should fall back to
  // a combination of &quot;Z5&quot; and other possibilities from the list of
  // requisite. If that&apos;s not possible, it should fall back  to a
  // combination of &quot;Z3&quot; and other possibilities from the list of
  // requisite. If that&apos;s not possible, it should fall back  to a
  // combination of other possibilities from the list of requisite.
  repeated Topology preferred = 2;
}

// Topology is a map of topological domains to topological segments.
// A topological domain is a sub-division of a cluster, like &quot;region&quot;,
// &quot;zone&quot;, &quot;rack&quot;, etc.
// A topological segment is a specific instance of a topological domain,
// like &quot;zone3&quot;, &quot;rack3&quot;, etc.
// For example {&quot;com.company/zone&quot;: &quot;Z1&quot;, &quot;com.company/rack&quot;: &quot;R3&quot;}
// Valid keys have two segments: an OPTIONAL prefix and name, separated
// by a slash (/), for example: &quot;com.company.example/zone&quot;.
// The key name segment is REQUIRED. The prefix is OPTIONAL.
// The key name MUST be 63 characters or less, begin and end with an
// alphanumeric character ([a-z0-9A-Z]), and contain only dashes (-),
// underscores (_), dots (.), or alphanumerics in between, for example
// &quot;zone&quot;.
// The key prefix MUST be 63 characters or less, begin and end with a
// lower-case alphanumeric character ([a-z0-9]), contain only
// dashes (-), dots (.), or lower-case alphanumerics in between, and
// follow domain name notation format
// (https://tools.ietf.org/html/rfc1035#section-2.3.1).
// The key prefix SHOULD include the plugin&apos;s host company name and/or
// the plugin name, to minimize the possibility of collisions with keys
// from other plugins.
// If a key prefix is specified, it MUST be identical across all
// topology keys returned by the SP (across all RPCs).
// Keys MUST be case-insensitive. Meaning the keys &quot;Zone&quot; and &quot;zone&quot;
// MUST not both exist.
// Each value (topological segment) MUST contain 1 or more strings.
// Each string MUST be 63 characters or less and begin and end with an
// alphanumeric character with &apos;-&apos;, &apos;_&apos;, &apos;.&apos;, or alphanumerics in
// between.
message Topology {
  map&amp;lt;string, string&amp;gt; segments = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;deletevolume&quot;&gt;DeleteVolume&lt;/h4&gt;
&lt;p&gt;此接口必须是幂等的，如果传入的volume_id已经不存在了，则plugin需返回OK。&lt;/p&gt;

&lt;p&gt;Plugin应该独立的对待volume和snapshot。如果Plugin支持在不影响其现有Snapshot的情况下删除Volume，那么这些Snapshot必须仍然是完全可操作的，并且可以作为新Volume的来源，并且在Volume被删除后出现在 ListSnapshot 调用中。当Plugin不支持删除Volume而不影响其现有Snapshot时，则请求不得以任何方式更改Volume，并且操作必须返回 FAILED_PRECONDITION 错误代码。&lt;/p&gt;

&lt;p&gt;在调用CreateVolume时假如发生了超时，则CO会拿不到volume_id。如果CO想要删除此volume，则可以采取以下行为：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;以相同的参数再次发起CreateVolume请求，一旦执行成功便可以拿到volume_id进行删除操作。&lt;/li&gt;
  &lt;li&gt;执行ListVolumes获取volume_id进行删除操作。&lt;/li&gt;
  &lt;li&gt;CO不做额外操作。由管理员做删除。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Plugin可以不支持&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LIST_VOLUME&lt;/code&gt;功能，CO在获取Plugin支持功能列表之后可以决定采取哪种方式处理上述情况。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message DeleteVolumeRequest {
  // The ID of the volume to be deprovisioned.
  // This field is REQUIRED.
  string volume_id = 1;

  // Secrets required by plugin to complete volume deletion request.
  // This field is OPTIONAL. Refer to the `Secrets Requirements`
  // section on how to use this field.
  map&amp;lt;string, string&amp;gt; secrets = 2 [(csi_secret) = true];
}

message DeleteVolumeResponse {
  // Intentionally empty.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;listvolumes&quot;&gt;ListVolumes&lt;/h4&gt;

&lt;p&gt;Plugin应返回有关它知道的所有Volume的信息。如果在CO对ListVolumes结果进行分页的同时创建或删除Volume，则列表中可能会出现重复的Volume，而不是获取现有的Volume，或两种情况都会发生。当通过多次调用ListVolumes翻阅Volume列表时，CO不应期望所有Volume的“视图”一致。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message ListVolumesRequest {
  // If specified (non-zero value), the Plugin MUST NOT return more
  // entries than this number in the response. If the actual number of
  // entries is more than this number, the Plugin MUST set `next_token`
  // in the response which can be used to get the next page of entries
  // in the subsequent `ListVolumes` call. This field is OPTIONAL. If
  // not specified (zero value), it means there is no restriction on the
  // number of entries that can be returned.
  // The value of this field MUST NOT be negative.
  int32 max_entries = 1;

  // A token to specify where to start paginating. Set this field to
  // `next_token` returned by a previous `ListVolumes` call to get the
  // next page of entries. This field is OPTIONAL.
  // An empty string is equal to an unspecified field value.
  string starting_token = 2;
}

message ListVolumesResponse {
  message VolumeStatus{
    // A list of all `node_id` of nodes that the volume in this entry
    // is controller published on.
    // This field is OPTIONAL. If it is not specified and the SP has
    // the LIST_VOLUMES_PUBLISHED_NODES controller capability, the CO
    // MAY assume the volume is not controller published to any nodes.
    // If the field is not specified and the SP does not have the
    // LIST_VOLUMES_PUBLISHED_NODES controller capability, the CO MUST
    // not interpret this field.
    // published_node_ids MAY include nodes not published to or
    // reported by the SP. The CO MUST be resilient to that.
    repeated string published_node_ids = 1;

    // Information about the current condition of the volume.
    // This field is OPTIONAL.
    // This field MUST be specified if the
    // VOLUME_CONDITION controller capability is supported.
    VolumeCondition volume_condition = 2 [(alpha_field) = true];
  }

  message Entry {
    // This field is REQUIRED
    Volume volume = 1;

    // This field is OPTIONAL. This field MUST be specified if the
    // LIST_VOLUMES_PUBLISHED_NODES controller capability is
    // supported.
    VolumeStatus status = 2;
  }

  repeated Entry entries = 1;

  // This token allows you to get the next page of entries for
  // `ListVolumes` request. If the number of entries is larger than
  // `max_entries`, use the `next_token` as a value for the
  // `starting_token` field in the next `ListVolumes` request. This
  // field is OPTIONAL.
  // An empty string is equal to an unspecified field value.
  string next_token = 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;controllergetvolume&quot;&gt;ControllerGetVolume&lt;/h4&gt;

&lt;p&gt;CO调用此接口可以获取Volume的详细信息，如果volume不存在，则plugin需返回NOT_FOUND&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message ControllerGetVolumeRequest {
  option (alpha_message) = true;

  // The ID of the volume to fetch current volume information for.
  // This field is REQUIRED.
  string volume_id = 1;
}

message ControllerGetVolumeResponse {
  option (alpha_message) = true;

  message VolumeStatus{
    // A list of all the `node_id` of nodes that this volume is
    // controller published on.
    // This field is OPTIONAL.
    // This field MUST be specified if the LIST_VOLUMES_PUBLISHED_NODES
    // controller capability is supported.
    // published_node_ids MAY include nodes not published to or
    // reported by the SP. The CO MUST be resilient to that.
    repeated string published_node_ids = 1;

    // Information about the current condition of the volume.
    // This field is OPTIONAL.
    // This field MUST be specified if the
    // VOLUME_CONDITION controller capability is supported.
    VolumeCondition volume_condition = 2;
  }

  // This field is REQUIRED
  Volume volume = 1;

  // This field is REQUIRED.
  VolumeStatus status = 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;validatevolumecapabilities&quot;&gt;ValidateVolumeCapabilities&lt;/h4&gt;

&lt;p&gt;Plugin必须提供此RPC接口，CO调用此接口确认一个pre-provisioned volume是否具有CO需要的所有功能。如果请求的所有的volume功能都被支持，则plugin只会返回confirmed。此操作必须是幂等的。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message ValidateVolumeCapabilitiesRequest {
  // The ID of the volume to check. This field is REQUIRED.
  string volume_id = 1;

  // Volume context as returned by SP in
  // CreateVolumeResponse.Volume.volume_context.
  // This field is OPTIONAL and MUST match the volume_context of the
  // volume identified by `volume_id`.
  map&amp;lt;string, string&amp;gt; volume_context = 2;

  // The capabilities that the CO wants to check for the volume. This
  // call SHALL return &quot;confirmed&quot; only if all the volume capabilities
  // specified below are supported. This field is REQUIRED.
  repeated VolumeCapability volume_capabilities = 3;

  // See CreateVolumeRequest.parameters.
  // This field is OPTIONAL.
  map&amp;lt;string, string&amp;gt; parameters = 4;

  // Secrets required by plugin to complete volume validation request.
  // This field is OPTIONAL. Refer to the `Secrets Requirements`
  // section on how to use this field.
  map&amp;lt;string, string&amp;gt; secrets = 5 [(csi_secret) = true];
}

message ValidateVolumeCapabilitiesResponse {
  message Confirmed {
    // Volume context validated by the plugin.
    // This field is OPTIONAL.
    map&amp;lt;string, string&amp;gt; volume_context = 1;

    // Volume capabilities supported by the plugin.
    // This field is REQUIRED.
    repeated VolumeCapability volume_capabilities = 2;

    // The volume creation parameters validated by the plugin.
    // This field is OPTIONAL.
    map&amp;lt;string, string&amp;gt; parameters = 3;
  }

  // Confirmed indicates to the CO the set of capabilities that the
  // plugin has validated. This field SHALL only be set to a non-empty
  // value for successful validation responses.
  // For successful validation responses, the CO SHALL compare the
  // fields of this message to the originally requested capabilities in
  // order to guard against an older plugin reporting &quot;valid&quot; for newer
  // capability fields that it does not yet understand.
  // This field is OPTIONAL.
  Confirmed confirmed = 1;

  // Message to the CO if `confirmed` above is empty. This field is
  // OPTIONAL.
  // An empty string is equal to an unspecified field value.
  string message = 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;controllerpublishvolume&quot;&gt;ControllerPublishVolume&lt;/h4&gt;

&lt;p&gt;当CO要将一个使用volume的workload放置到一个节点时，会调用此接口。plugin应该执行必要的操作使该volume在此节点上可用。Plugin不得假定此RPC在将使用Volume的节点上执行。此操作必须是幂等的。如果volume_id对应的volume已经在node_id对应的节点上发布过，并且兼容指定的volume_capability和readonly标志，则Plugin必须回复&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 OK&lt;/code&gt;。如果操作失败或者CO不确定操作是否失败，它可以选择再次调用ControllerPublishVolume或选择调用ControllerUnpublishVolume。&lt;/p&gt;

&lt;p&gt;如果Volume具有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MULTI_NODE&lt;/code&gt;功能(即MULTI_NODE_READER_ONLY、MULTI_NODE_SINGLE_WRITER或MULTI_NODE_MULTI_WRITER)，CO可以调用此RPC将Volume发布到多个节点。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message ControllerPublishVolumeRequest {
  // The ID of the volume to be used on a node.
  // This field is REQUIRED.
  string volume_id = 1;

  // The ID of the node. This field is REQUIRED. The CO SHALL set this
  // field to match the node ID returned by `NodeGetInfo`.
  string node_id = 2;

  // Volume capability describing how the CO intends to use this volume.
  // SP MUST ensure the CO can use the published volume as described.
  // Otherwise SP MUST return the appropriate gRPC error code.
  // This is a REQUIRED field.
  VolumeCapability volume_capability = 3;

  // Indicates SP MUST publish the volume in readonly mode.
  // CO MUST set this field to false if SP does not have the
  // PUBLISH_READONLY controller capability.
  // This is a REQUIRED field.
  bool readonly = 4;

  // Secrets required by plugin to complete controller publish volume
  // request. This field is OPTIONAL. Refer to the
  // `Secrets Requirements` section on how to use this field.
  map&amp;lt;string, string&amp;gt; secrets = 5 [(csi_secret) = true];

  // Volume context as returned by SP in
  // CreateVolumeResponse.Volume.volume_context.
  // This field is OPTIONAL and MUST match the volume_context of the
  // volume identified by `volume_id`.
  map&amp;lt;string, string&amp;gt; volume_context = 6;
}

message ControllerPublishVolumeResponse {
  // Opaque static publish properties of the volume. SP MAY use this
  // field to ensure subsequent `NodeStageVolume` or `NodePublishVolume`
  // calls calls have contextual information.
  // The contents of this field SHALL be opaque to a CO.
  // The contents of this field SHALL NOT be mutable.
  // The contents of this field SHALL be safe for the CO to cache.
  // The contents of this field SHOULD NOT contain sensitive
  // information.
  // The contents of this field SHOULD NOT be used for uniquely
  // identifying a volume. The `volume_id` alone SHOULD be sufficient to
  // identify the volume.
  // This field is OPTIONAL and when present MUST be passed to
  // subsequent `NodeStageVolume` or `NodePublishVolume` calls
  map&amp;lt;string, string&amp;gt; publish_context = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;controllerunpublishvolume&quot;&gt;ControllerUnPublishVolume&lt;/h4&gt;

&lt;p&gt;当使用Volume的工作负载被移动到不同的节点，或者在节点上使用Volume的所有工作负载已经完成时，CO会调用此接口。Plugin应该执行使Volume准备好被不同节点使用所需的工作。Plugin不得假定此RPC在将要使用此Volume的节点上执行。此调用必须在成功调用NodeUnstageVolume和NodeUnpublishVolume之后调用。此操作必须是幂等的。如果 volume_id 对应的Volume没有附加到 node_id 对应的节点上，Plugin必须回复 0 OK。如果Plugin无法找到volume_id对应的Volume或node_id对应的节点，并且Volume可以视为安全地从节点ControllerUnpublished，则Plugin应该返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 OK&lt;/code&gt;。如果此操作失败，或者 CO 不知道操作是否失败，它可以选择再次调用 ControllerUnpublishVolume。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message ControllerUnpublishVolumeRequest {
  // The ID of the volume. This field is REQUIRED.
  string volume_id = 1;

  // The ID of the node. This field is OPTIONAL. The CO SHOULD set this
  // field to match the node ID returned by `NodeGetInfo` or leave it
  // unset. If the value is set, the SP MUST unpublish the volume from
  // the specified node. If the value is unset, the SP MUST unpublish
  // the volume from all nodes it is published to.
  string node_id = 2;

  // Secrets required by plugin to complete controller unpublish volume
  // request. This SHOULD be the same secrets passed to the
  // ControllerPublishVolume call for the specified volume.
  // This field is OPTIONAL. Refer to the `Secrets Requirements`
  // section on how to use this field.
  map&amp;lt;string, string&amp;gt; secrets = 3 [(csi_secret) = true];
}

message ControllerUnpublishVolumeResponse {
  // Intentionally empty.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;createsnapshot&quot;&gt;CreateSnapshot&lt;/h4&gt;
&lt;p&gt;CO调用此RPC从源Volume创建新Snapshot。此操作必须是幂等的。如果与指定Snapshot成功创建并准备好使用（意味着它可以在CreateVolumeRequest中指定为volume_content_source），则Plugin必须回复&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 OK&lt;/code&gt;。如果在创建Snapshot之前发生错误，则CreateSnapshot应返回相应错误代码。&lt;/p&gt;

&lt;p&gt;一些SP可能会在Snapshot剪切后“处理”Snapshot，例如，可能在Snapshot剪切后将Snapshot上传到某处。后期剪辑过程可能是一个漫长的过程，可能需要数小时。CO可以在拍摄Snapshot之前使用源Volume冻结应用程序。冻结的目的是保证应用数据处于一致状态。执行冻结时，容器会暂停，应用程序也会暂停。执行解冻后，容器和应用程序将再次开始运行。在Snapshot处理阶段，由于Snapshot已经被剪切，因此可以执行解冻操作，因此应用程序可以开始运行而无需等待该过程完成。该过程完成后，Snapshot的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ready_to_use&lt;/code&gt;参数将变为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;。当Snapshot已经被创建但是仍在被处理时，CreateSnapshot应该返回&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 OK&lt;/code&gt;但是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ready_to_use&lt;/code&gt;应该设置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt;。然后，CO 应该定期重新发出相同的CreateSnapshotRequest，直到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ready_to_use&lt;/code&gt;被设置为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;，此时的Snapshot已被处理并准备好用于创建新Volume。如果过程中发生错误，CreateSnapshot应该返回一个反映错误情况的错误代码。当发生错误时，CO应该明确删除Snapshot。&lt;/p&gt;

&lt;p&gt;对于剪切后不做额外处理的 SP，在剪切Snapshot后&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ready_to_use&lt;/code&gt;参数应该为真。在这种情况下，可以在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ready_to_use&lt;/code&gt;参数为真时完成解冻。&lt;/p&gt;

&lt;p&gt;CO 可以向 CreateSnapshot 发出重复（幂等）调用、监控响应并做出决策。CreateSnapshot是一个同步调用，它必须阻塞直到Snapshot被成功创建。&lt;/p&gt;

&lt;p&gt;Snapshot可以用作供应新Volume的源。CreateVolumeRequest消息可以指定一个可选的源Snapshot参数。从Snapshot中恢复数据（原始Volume中的数据被擦除并替换为Snapshot中的数据）是一项高级功能，并非每个存储系统都可以支持，因此目前超出范围。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message CreateSnapshotRequest {
  // The ID of the source volume to be snapshotted.
  // This field is REQUIRED.
  string source_volume_id = 1;

  // The suggested name for the snapshot. This field is REQUIRED for
  // idempotency.
  // Any Unicode string that conforms to the length limit is allowed
  // except those containing the following banned characters:
  // U+0000-U+0008, U+000B, U+000C, U+000E-U+001F, U+007F-U+009F.
  // (These are control characters other than commonly used whitespace.)
  string name = 2;

  // Secrets required by plugin to complete snapshot creation request.
  // This field is OPTIONAL. Refer to the `Secrets Requirements`
  // section on how to use this field.
  map&amp;lt;string, string&amp;gt; secrets = 3 [(csi_secret) = true];

  // Plugin specific parameters passed in as opaque key-value pairs.
  // This field is OPTIONAL. The Plugin is responsible for parsing and
  // validating these parameters. COs will treat these as opaque.
  // Use cases for opaque parameters:
  // - Specify a policy to automatically clean up the snapshot.
  // - Specify an expiration date for the snapshot.
  // - Specify whether the snapshot is readonly or read/write.
  // - Specify if the snapshot should be replicated to some place.
  // - Specify primary or secondary for replication systems that
  //   support snapshotting only on primary.
  map&amp;lt;string, string&amp;gt; parameters = 4;
}

message CreateSnapshotResponse {
  // Contains all attributes of the newly created snapshot that are
  // relevant to the CO along with information required by the Plugin
  // to uniquely identify the snapshot. This field is REQUIRED.
  Snapshot snapshot = 1;
}

// Information about a specific snapshot.
message Snapshot {
  // This is the complete size of the snapshot in bytes. The purpose of
  // this field is to give CO guidance on how much space is needed to
  // create a volume from this snapshot. The size of the volume MUST NOT
  // be less than the size of the source snapshot. This field is
  // OPTIONAL. If this field is not set, it indicates that this size is
  // unknown. The value of this field MUST NOT be negative and a size of
  // zero means it is unspecified.
  int64 size_bytes = 1;

  // The identifier for this snapshot, generated by the plugin.
  // This field is REQUIRED.
  // This field MUST contain enough information to uniquely identify
  // this specific snapshot vs all other snapshots supported by this
  // plugin.
  // This field SHALL be used by the CO in subsequent calls to refer to
  // this snapshot.
  // The SP is NOT responsible for global uniqueness of snapshot_id
  // across multiple SPs.
  string snapshot_id = 2;

  // Identity information for the source volume. Note that creating a
  // snapshot from a snapshot is not supported here so the source has to
  // be a volume. This field is REQUIRED.
  string source_volume_id = 3;

  // Timestamp when the point-in-time snapshot is taken on the storage
  // system. This field is REQUIRED.
  .google.protobuf.Timestamp creation_time = 4;

  // Indicates if a snapshot is ready to use as a
  // `volume_content_source` in a `CreateVolumeRequest`. The default
  // value is false. This field is REQUIRED.
  bool ready_to_use = 5;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;deletesnapshot&quot;&gt;DeleteSnapshot&lt;/h4&gt;
&lt;p&gt;CO将调用此RPC删除Snapshot。此操作必须是幂等的。如果对应于指定snapshot_id的Snapshot不存在，Plugin必须回复 0 OK。
当SnapShot被成功创建时，CreateSnapshot操作应该返回一个snapshot_id。如果CreateSnapshot操作在创建SnapShot之前超时，使CO没有获取snapshot_id，则CO可以选择以下之一路径将其删除：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;执行ListSnapshots以获得可用于执行DeleteSnapshot的SnapShot ID；成功后执行DeleteSnapshot。&lt;/li&gt;
  &lt;li&gt;CO不对超时的RPC采取进一步行动，SnapShot可能会泄露，由操作员/用户进行清理。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message DeleteSnapshotRequest {
  // The ID of the snapshot to be deleted.
  // This field is REQUIRED.
  string snapshot_id = 1;

  // Secrets required by plugin to complete snapshot deletion request.
  // This field is OPTIONAL. Refer to the `Secrets Requirements`
  // section on how to use this field.
  map&amp;lt;string, string&amp;gt; secrets = 2 [(csi_secret) = true];
}

message DeleteSnapshotResponse {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;listsnapshots&quot;&gt;ListSnapshots&lt;/h4&gt;

&lt;p&gt;Plugin应在给定参数内返回有关存储系统上所有Snapshot的信息。ListSnapshots不应列出正在创建但尚未成功剪切的Snapshot。如果在CO分页ListSnapshots结果的同时创建或删除Snapshot，则CO可能在列表中发现重复的Snapshot，没有出现现有的Snapshot，或两者兼而有之。当Snapshot的后处理完成后，SnapShot的ready_to_use参数应变为true。调用ListSnapshots的缺点是，如果在处理过程中发生错误，ListSnapshots将不会返回错误代码。所以反复调用 CreateSnapshot 是检查处理是否完成的首选方式。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// List all snapshots on the storage system regardless of how they were
// created.
message ListSnapshotsRequest {
  // If specified (non-zero value), the Plugin MUST NOT return more
  // entries than this number in the response. If the actual number of
  // entries is more than this number, the Plugin MUST set `next_token`
  // in the response which can be used to get the next page of entries
  // in the subsequent `ListSnapshots` call. This field is OPTIONAL. If
  // not specified (zero value), it means there is no restriction on the
  // number of entries that can be returned.
  // The value of this field MUST NOT be negative.
  int32 max_entries = 1;

  // A token to specify where to start paginating. Set this field to
  // `next_token` returned by a previous `ListSnapshots` call to get the
  // next page of entries. This field is OPTIONAL.
  // An empty string is equal to an unspecified field value.
  string starting_token = 2;

  // Identity information for the source volume. This field is OPTIONAL.
  // It can be used to list snapshots by volume.
  string source_volume_id = 3;

  // Identity information for a specific snapshot. This field is
  // OPTIONAL. It can be used to list only a specific snapshot.
  // ListSnapshots will return with current snapshot information
  // and will not block if the snapshot is being processed after
  // it is cut.
  string snapshot_id = 4;

  // Secrets required by plugin to complete ListSnapshot request.
  // This field is OPTIONAL. Refer to the `Secrets Requirements`
  // section on how to use this field.
  map&amp;lt;string, string&amp;gt; secrets = 5 [(csi_secret) = true];
}

message ListSnapshotsResponse {
  message Entry {
    Snapshot snapshot = 1;
  }

  repeated Entry entries = 1;

  // This token allows you to get the next page of entries for
  // `ListSnapshots` request. If the number of entries is larger than
  // `max_entries`, use the `next_token` as a value for the
  // `starting_token` field in the next `ListSnapshots` request. This
  // field is OPTIONAL.
  // An empty string is equal to an unspecified field value.
  string next_token = 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;getcapacity&quot;&gt;GetCapacity&lt;/h4&gt;
&lt;p&gt;该RPC允许CO查询Plugin提供Volume的Storage pool的容量。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message GetCapacityRequest {
  // If specified, the Plugin SHALL report the capacity of the storage
  // that can be used to provision volumes that satisfy ALL of the
  // specified `volume_capabilities`. These are the same
  // `volume_capabilities` the CO will use in `CreateVolumeRequest`.
  // This field is OPTIONAL.
  repeated VolumeCapability volume_capabilities = 1;

  // If specified, the Plugin SHALL report the capacity of the storage
  // that can be used to provision volumes with the given Plugin
  // specific `parameters`. These are the same `parameters` the CO will
  // use in `CreateVolumeRequest`. This field is OPTIONAL.
  map&amp;lt;string, string&amp;gt; parameters = 2;

  // If specified, the Plugin SHALL report the capacity of the storage
  // that can be used to provision volumes that in the specified
  // `accessible_topology`. This is the same as the
  // `accessible_topology` the CO returns in a `CreateVolumeResponse`.
  // This field is OPTIONAL. This field SHALL NOT be set unless the
  // plugin advertises the VOLUME_ACCESSIBILITY_CONSTRAINTS capability.
  Topology accessible_topology = 3;
}

message GetCapacityResponse {
  // The available capacity, in bytes, of the storage that can be used
  // to provision volumes. If `volume_capabilities` or `parameters` is
  // specified in the request, the Plugin SHALL take those into
  // consideration when calculating the available capacity of the
  // storage. This field is REQUIRED.
  // The value of this field MUST NOT be negative.
  int64 available_capacity = 1;

  // The largest size that may be used in a
  // CreateVolumeRequest.capacity_range.required_bytes field
  // to create a volume with the same parameters as those in
  // GetCapacityRequest.
  //
  // If `volume_capabilities` or `parameters` is
  // specified in the request, the Plugin SHALL take those into
  // consideration when calculating the minimum volume size of the
  // storage.
  //
  // This field is OPTIONAL. MUST NOT be negative.
  // The Plugin SHOULD provide a value for this field if it has
  // a maximum size for individual volumes and leave it unset
  // otherwise. COs MAY use it to make decision about
  // where to create volumes.
  google.protobuf.Int64Value maximum_volume_size = 2
    [(alpha_field) = true];

  // The smallest size that may be used in a
  // CreateVolumeRequest.capacity_range.limit_bytes field
  // to create a volume with the same parameters as those in
  // GetCapacityRequest.
  //
  // If `volume_capabilities` or `parameters` is
  // specified in the request, the Plugin SHALL take those into
  // consideration when calculating the maximum volume size of the
  // storage.
  //
  // This field is OPTIONAL. MUST NOT be negative.
  // The Plugin SHOULD provide a value for this field if it has
  // a minimum size for individual volumes and leave it unset
  // otherwise. COs MAY use it to make decision about
  // where to create volumes.
  google.protobuf.Int64Value minimum_volume_size = 3
    [(alpha_field) = true];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;controllerexpandvolume&quot;&gt;ControllerExpandVolume&lt;/h4&gt;
&lt;p&gt;此RPC允许CO扩展Volume的大小。该操作必须是幂等的。如果指定VolumeID对应的Volume已经大于或等于扩展请求的目标容量，则Plugin应该回复&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 OK&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果Plugin具有VolumeExpansion.ONLINE功能，则CO可以在创建Volume后的任何时间调用此接口。如果Plugin具有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EXPAND_VOLUME&lt;/code&gt;的node capability，则必须在调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerExpandVolume&lt;/code&gt;成功且ControllerExpandVolumeResponse中的node_expansion_required为true后调用 NodeExpandVolume。&lt;/p&gt;

&lt;p&gt;如果在ControllerExpandVolumeRequest中指定了volume_capability，则其应该与CO在ControllerPublishVolumeRequest中传递的参数相同。&lt;/p&gt;

&lt;p&gt;如果Plugin只有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VolumeExpansion.OFFLINE&lt;/code&gt;扩展功能并且Volume当前已发布或在节点上可用，则ControllerExpandVolume必须仅在以下任一情况后调用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;该Plugin具有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUBLISH_UNPUBLISH_VOLUME&lt;/code&gt;功能并且&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerUnpublishVolume&lt;/code&gt;已成功调用。或者&lt;/li&gt;
  &lt;li&gt;该Plugin没有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUBLISH_UNPUBLISH_VOLUME&lt;/code&gt;功能，但是Plugin具有Node &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STAGE_UNSTAGE_VOLUME&lt;/code&gt;功能，并且&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeUnstageVolume&lt;/code&gt;已成功完成。或者&lt;/li&gt;
  &lt;li&gt;该Plugin没有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUBLISH_UNPUBLISH_VOLUME&lt;/code&gt;功能，也没有Node &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STAGE_UNSTAGE_VOLUME&lt;/code&gt;功能，并且&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeUnpublishVolume &lt;/code&gt;已成功完成。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message ControllerExpandVolumeRequest {
  // The ID of the volume to expand. This field is REQUIRED.
  string volume_id = 1;

  // This allows CO to specify the capacity requirements of the volume
  // after expansion. This field is REQUIRED.
  CapacityRange capacity_range = 2;

  // Secrets required by the plugin for expanding the volume.
  // This field is OPTIONAL.
  map&amp;lt;string, string&amp;gt; secrets = 3 [(csi_secret) = true];

  // Volume capability describing how the CO intends to use this volume.
  // This allows SP to determine if volume is being used as a block
  // device or mounted file system. For example - if volume is
  // being used as a block device - the SP MAY set
  // node_expansion_required to false in ControllerExpandVolumeResponse
  // to skip invocation of NodeExpandVolume on the node by the CO.
  // This is an OPTIONAL field.
  VolumeCapability volume_capability = 4;
}

message ControllerExpandVolumeResponse {
  // Capacity of volume after expansion. This field is REQUIRED.
  int64 capacity_bytes = 1;

  // Whether node expansion is required for the volume. When true
  // the CO MUST make NodeExpandVolume RPC call on the node. This field
  // is REQUIRED.
  bool node_expansion_required = 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;node-service-rpc&quot;&gt;Node Service RPC&lt;/h3&gt;

&lt;p&gt;Node Service RPC是Node Plugin需要向外暴露的接口。&lt;/p&gt;

&lt;h4 id=&quot;nodegetcapabilities&quot;&gt;NodeGetCapabilities&lt;/h4&gt;
&lt;p&gt;Node Plugin必须实现此接口，该接口允许CO检查Node Plugin所支持的功能。&lt;/p&gt;

&lt;p&gt;各类功能和RPC接口的对应关系见下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Cpability&lt;/th&gt;
      &lt;th&gt;RPCs&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;MUST_IMPLEMENT&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodePublishVolume&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeUnpublishVolume&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeGetCapabilities&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;STAGE_UNSTAGE_VOLUME&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeStageVolume&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeUnstageVolume&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GET_VOLUME_STATS&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeGetVolumeStats&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EXPAND_VOLUME&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeExpandVolume&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VOLUME_CONDITION&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeGetVolumeStats&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SINGLE_NODE_MULTI_WRITER&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodePublishVolume&lt;/code&gt; support SINGLE_NODE_MULTI_WRITER access modes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VOLUME_MOUNT_GROUP&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodePublishVolume&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeStageVolume&lt;/code&gt; support mounting volumes with provided volume group identifier&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message NodeGetCapabilitiesRequest {
  // Intentionally empty.
}

message NodeGetCapabilitiesResponse {
  // All the capabilities that the node service supports. This field
  // is OPTIONAL.
  repeated NodeServiceCapability capabilities = 1;
}

// Specifies a capability of the node service.
message NodeServiceCapability {
  message RPC {
    enum Type {
      UNKNOWN = 0;
      STAGE_UNSTAGE_VOLUME = 1;
      // If Plugin implements GET_VOLUME_STATS capability
      // then it MUST implement NodeGetVolumeStats RPC
      // call for fetching volume statistics.
      GET_VOLUME_STATS = 2;
      // See VolumeExpansion for details.
      EXPAND_VOLUME = 3;
      // Indicates that the Node service can report volume conditions.
      // An SP MAY implement `VolumeCondition` in only the Node
      // Plugin, only the Controller Plugin, or both.
      // If `VolumeCondition` is implemented in both the Node and
      // Controller Plugins, it SHALL report from different
      // perspectives.
      // If for some reason Node and Controller Plugins report
      // misaligned volume conditions, CO SHALL assume the worst case
      // is the truth.
      // Note that, for alpha, `VolumeCondition` is intended to be
      // informative for humans only, not for automation.
      VOLUME_CONDITION = 4 [(alpha_enum_value) = true];

      // Indicates the SP supports the SINGLE_NODE_SINGLE_WRITER and/or
      // SINGLE_NODE_MULTI_WRITER access modes.
      // These access modes are intended to replace the
      // SINGLE_NODE_WRITER access mode to clarify the number of writers
      // for a volume on a single node. Plugins MUST accept and allow
      // use of the SINGLE_NODE_WRITER access mode (subject to the
      // processing rules for NodePublishVolume), when either
      // SINGLE_NODE_SINGLE_WRITER and/or SINGLE_NODE_MULTI_WRITER are
      // supported, in order to permit older COs to continue working.
      SINGLE_NODE_MULTI_WRITER = 5 [(alpha_enum_value) = true];

      // Indicates that Node service supports mounting volumes
      // with provided volume group identifier during node stage
      // or node publish RPC calls.
      VOLUME_MOUNT_GROUP = 6 [(alpha_enum_value) = true];
    }

    Type type = 1;
  }

  oneof type {
    // RPC that the controller supports.
    RPC rpc = 1;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;nodegetinfo&quot;&gt;NodeGetInfo&lt;/h4&gt;
&lt;p&gt;当Plugin具有Controller &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUBLISH_UNPUBLISH_VOLUME&lt;/code&gt;功能是，plugin必须提供此RPC接口。Plugin可以假定调用发生在将要使用volume的节点上。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message NodeGetInfoRequest {
}

message NodeGetInfoResponse {
  // The identifier of the node as understood by the SP.
  // This field is REQUIRED.
  // This field MUST contain enough information to uniquely identify
  // this specific node vs all other nodes supported by this plugin.
  // This field SHALL be used by the CO in subsequent calls, including
  // `ControllerPublishVolume`, to refer to this node.
  // The SP is NOT responsible for global uniqueness of node_id across
  // multiple SPs.
  // This field overrides the general CSI size limit.
  // The size of this field SHALL NOT exceed 256 bytes. The general
  // CSI size limit, 128 byte, is RECOMMENDED for best backwards
  // compatibility.
  string node_id = 1;

  // Maximum number of volumes that controller can publish to the node.
  // If value is not set or zero CO SHALL decide how many volumes of
  // this type can be published by the controller to the node. The
  // plugin MUST NOT set negative values here.
  // This field is OPTIONAL.
  int64 max_volumes_per_node = 2;

  // Specifies where (regions, zones, racks, etc.) the node is
  // accessible from.
  // A plugin that returns this field MUST also set the
  // VOLUME_ACCESSIBILITY_CONSTRAINTS plugin capability.
  // COs MAY use this information along with the topology information
  // returned in CreateVolumeResponse to ensure that a given volume is
  // accessible from a given node when scheduling workloads.
  // This field is OPTIONAL. If it is not specified, the CO MAY assume
  // the node is not subject to any topological constraint, and MAY
  // schedule workloads that reference any volume V, such that there are
  // no topological constraints declared for V.
  //
  // Example 1:
  //   accessible_topology =
  //     {&quot;region&quot;: &quot;R1&quot;, &quot;zone&quot;: &quot;Z2&quot;}
  // Indicates the node exists within the &quot;region&quot; &quot;R1&quot; and the &quot;zone&quot;
  // &quot;Z2&quot;.
  Topology accessible_topology = 3;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;nodestagevolume&quot;&gt;NodeStageVolume&lt;/h4&gt;
&lt;p&gt;在调用NodePublishVolume接口使节点上的工作负载消费该卷之前，CO会调用此RPC。Plugin应假定此RPC将在将使用卷的节点上执行。当想要使用指定卷的工作负载第一次调度到该节点上，或者指定卷的NodeUnstageVolume成功调用之后再次调度到该节点时，CO应该调用此接口。&lt;/p&gt;

&lt;p&gt;如果对应的Controller Plugin具有PUBLISH_UNPUBLISH_VOLUME能力并且Node Plugin具有STAGE_UNSTAGE_VOLUME能力，那么CO必须保证在为给定节点上的给定卷调用ControllerPublishVolume并返回成功后调用此RPC。CO还必须保证在为给定节点上的给定卷调用任何NodePublishVolume之前成功调用此RPC。&lt;/p&gt;

&lt;p&gt;此操作必须是幂等的。如果对应于 volume_id的卷已经上演到&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;staging_target_path&lt;/code&gt;，并且与指定的volume_capability相同，则插件必须回复&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 OK&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果这个RPC失败，或者CO不知道它是否失败，它可以选择再次调用NodeStageVolume，或者选择调用 NodeUnstageVolume。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message NodeStageVolumeRequest {
  // The ID of the volume to publish. This field is REQUIRED.
  string volume_id = 1;

  // The CO SHALL set this field to the value returned by
  // `ControllerPublishVolume` if the corresponding Controller Plugin
  // has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
  // left unset if the corresponding Controller Plugin does not have
  // this capability. This is an OPTIONAL field.
  map&amp;lt;string, string&amp;gt; publish_context = 2;

  // The path to which the volume MAY be staged. It MUST be an
  // absolute path in the root filesystem of the process serving this
  // request, and MUST be a directory. The CO SHALL ensure that there
  // is only one `staging_target_path` per volume. The CO SHALL ensure
  // that the path is directory and that the process serving the
  // request has `read` and `write` permission to that directory. The
  // CO SHALL be responsible for creating the directory if it does not
  // exist.
  // This is a REQUIRED field.
  // This field overrides the general CSI size limit.
  // SP SHOULD support the maximum path length allowed by the operating
  // system/filesystem, but, at a minimum, SP MUST accept a max path
  // length of at least 128 bytes.
  string staging_target_path = 3;

  // Volume capability describing how the CO intends to use this volume.
  // SP MUST ensure the CO can use the staged volume as described.
  // Otherwise SP MUST return the appropriate gRPC error code.
  // This is a REQUIRED field.
  VolumeCapability volume_capability = 4;

  // Secrets required by plugin to complete node stage volume request.
  // This field is OPTIONAL. Refer to the `Secrets Requirements`
  // section on how to use this field.
  map&amp;lt;string, string&amp;gt; secrets = 5 [(csi_secret) = true];

  // Volume context as returned by SP in
  // CreateVolumeResponse.Volume.volume_context.
  // This field is OPTIONAL and MUST match the volume_context of the
  // volume identified by `volume_id`.
  map&amp;lt;string, string&amp;gt; volume_context = 6;
}

message NodeStageVolumeResponse {
  // Intentionally empty.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;nodeunstagevolume&quot;&gt;NodeUnstageVolume&lt;/h4&gt;
&lt;p&gt;此RPC是NodeStageVolume的逆向操作，其必须撤消相应 NodeStageVolume 的工作。对于通过NodeStageVolume成功设置的每个staging_target_path，CO都应调用此RPC一次。当使用卷的工作负载被移动到不同的节点时，或者使用节点上的卷的所有工作负载已经完成时，这个RPC可以被CO调用。此操作必须是幂等的,如果与volume_id对应的卷没有staged到staging_target_path，插件必须回复&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 OK&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果相应的Plugin Controller具有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUBLISH_UNPUBLISH_VOLUME&lt;/code&gt;能力并且Node Plugin具有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STAGE_UNSTAGE_VOLUME&lt;/code&gt;能力，则 CO必须保证在调用给定节点和给定卷的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ControllerUnpublishVolume&lt;/code&gt;之前成功调用此RPC。 CO还必须保证在所有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeUnpublishVolume&lt;/code&gt;都被成功调用之后调用此RPC。插件应假定此RPC将在使用卷的节点上执行。&lt;/p&gt;

&lt;p&gt;如果这个RPC失败，或者CO不知道它是否失败，它可以选择再次调用NodeUnstageVolume。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message NodeUnstageVolumeRequest {
  // The ID of the volume. This field is REQUIRED.
  string volume_id = 1;

  // The path at which the volume was staged. It MUST be an absolute
  // path in the root filesystem of the process serving this request.
  // This is a REQUIRED field.
  // This field overrides the general CSI size limit.
  // SP SHOULD support the maximum path length allowed by the operating
  // system/filesystem, but, at a minimum, SP MUST accept a max path
  // length of at least 128 bytes.
  string staging_target_path = 2;
}

message NodeUnstageVolumeResponse {
  // Intentionally empty.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;nodepublishvolume&quot;&gt;NodePublishVolume&lt;/h4&gt;
&lt;p&gt;当要使用指定卷的工作负载已经调度在节点上时，CO会调用此RPC。插件应假定此RPC将在将使用卷的节点上执行。此操作必须是幂等的，如果volume_id对应的卷已经在指定的target_path上发布，并且与指定的volume_capability和readonly标志兼容，则插件必须回复&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 OK&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果这个RPC失败，或者CO不知道它是否失败，它可以选择再次调用NodePublishVolume，或者选择调用NodeUnpublishVolume。&lt;/p&gt;

&lt;p&gt;如果卷支持 MULTI_NODE_*或者SINGLE_NODE_MULTI_WRITER访问模式，则CO可以在同一节点上多次调用此RPC以使用不同的target_path或其他参数。CO不应使用不同的 volume_capability再次调用NodePublishVolume。如果发生这种情况，插件应该返回FAILED_PRECONDITION。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message NodePublishVolumeRequest {
  // The ID of the volume to publish. This field is REQUIRED.
  string volume_id = 1;

  // The CO SHALL set this field to the value returned by
  // `ControllerPublishVolume` if the corresponding Controller Plugin
  // has `PUBLISH_UNPUBLISH_VOLUME` controller capability, and SHALL be
  // left unset if the corresponding Controller Plugin does not have
  // this capability. This is an OPTIONAL field.
  map&amp;lt;string, string&amp;gt; publish_context = 2;

  // The path to which the volume was staged by `NodeStageVolume`.
  // It MUST be an absolute path in the root filesystem of the process
  // serving this request.
  // It MUST be set if the Node Plugin implements the
  // `STAGE_UNSTAGE_VOLUME` node capability.
  // This is an OPTIONAL field.
  // This field overrides the general CSI size limit.
  // SP SHOULD support the maximum path length allowed by the operating
  // system/filesystem, but, at a minimum, SP MUST accept a max path
  // length of at least 128 bytes.
  string staging_target_path = 3;

  // The path to which the volume will be published. It MUST be an
  // absolute path in the root filesystem of the process serving this
  // request. The CO SHALL ensure uniqueness of target_path per volume.
  // The CO SHALL ensure that the parent directory of this path exists
  // and that the process serving the request has `read` and `write`
  // permissions to that parent directory.
  // For volumes with an access type of block, the SP SHALL place the
  // block device at target_path.
  // For volumes with an access type of mount, the SP SHALL place the
  // mounted directory at target_path.
  // Creation of target_path is the responsibility of the SP.
  // This is a REQUIRED field.
  // This field overrides the general CSI size limit.
  // SP SHOULD support the maximum path length allowed by the operating
  // system/filesystem, but, at a minimum, SP MUST accept a max path
  // length of at least 128 bytes.
  string target_path = 4;

  // Volume capability describing how the CO intends to use this volume.
  // SP MUST ensure the CO can use the published volume as described.
  // Otherwise SP MUST return the appropriate gRPC error code.
  // This is a REQUIRED field.
  VolumeCapability volume_capability = 5;

  // Indicates SP MUST publish the volume in readonly mode.
  // This field is REQUIRED.
  bool readonly = 6;

  // Secrets required by plugin to complete node publish volume request.
  // This field is OPTIONAL. Refer to the `Secrets Requirements`
  // section on how to use this field.
  map&amp;lt;string, string&amp;gt; secrets = 7 [(csi_secret) = true];

  // Volume context as returned by SP in
  // CreateVolumeResponse.Volume.volume_context.
  // This field is OPTIONAL and MUST match the volume_context of the
  // volume identified by `volume_id`.
  map&amp;lt;string, string&amp;gt; volume_context = 8;
}

message NodePublishVolumeResponse {
  // Intentionally empty.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;nodeunpublishvolume&quot;&gt;NodeUnpublishVolume&lt;/h4&gt;
&lt;p&gt;这个RPC是NodePublishVolume的逆向操作。此RPC必须撤消相应NodePublishVolume的工作。对于通过NodePublishVolume成功设置的每个target_path，CO应至少调用一次该RPC。插件应假定此 RPC 将在使用卷的节点上执行。此操作必须是幂等的。如果这个RPC失败，或者CO不知道它是否失败，它可以选择再次调用NodeUnpublishVolume。&lt;/p&gt;

&lt;p&gt;当使用卷的工作负载被移动到不同的节点，或者在节点上使用卷的所有工作负载已经完成时，这个RPC通常由CO调用。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message NodeUnpublishVolumeRequest {
  // The ID of the volume. This field is REQUIRED.
  string volume_id = 1;

  // The path at which the volume was published. It MUST be an absolute
  // path in the root filesystem of the process serving this request.
  // The SP MUST delete the file or directory it created at this path.
  // This is a REQUIRED field.
  // This field overrides the general CSI size limit.
  // SP SHOULD support the maximum path length allowed by the operating
  // system/filesystem, but, at a minimum, SP MUST accept a max path
  // length of at least 128 bytes.
  string target_path = 2;
}

message NodeUnpublishVolumeResponse {
  // Intentionally empty.
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;nodegetvolumestats&quot;&gt;NodeGetVolumeStats&lt;/h4&gt;
&lt;p&gt;NodeGetVolumeStats调用返回卷可用的卷容量统计信息。如果卷在BlockVolume模式下使用，则used和available可以从NodeGetVolumeStatsResponse的使用字段中省略。类似地，当节点不可用时，节点信息可以从 NodeGetVolumeStatsResponse 中省略。&lt;/p&gt;

&lt;p&gt;staging_target_path 字段不是必需的，为了向后兼容，但 CO 应该提供它。插件可以使用此字段来确定 volume_path 是否是发布或暂存卷的位置，并将此字段设置为非空允许插件在节点上存储较少状态的情况下运行。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message NodeGetVolumeStatsRequest {
  // The ID of the volume. This field is REQUIRED.
  string volume_id = 1;

  // It can be any valid path where volume was previously
  // staged or published.
  // It MUST be an absolute path in the root filesystem of
  // the process serving this request.
  // This is a REQUIRED field.
  // This field overrides the general CSI size limit.
  // SP SHOULD support the maximum path length allowed by the operating
  // system/filesystem, but, at a minimum, SP MUST accept a max path
  // length of at least 128 bytes.
  string volume_path = 2;

  // The path where the volume is staged, if the plugin has the
  // STAGE_UNSTAGE_VOLUME capability, otherwise empty.
  // If not empty, it MUST be an absolute path in the root
  // filesystem of the process serving this request.
  // This field is OPTIONAL.
  // This field overrides the general CSI size limit.
  // SP SHOULD support the maximum path length allowed by the operating
  // system/filesystem, but, at a minimum, SP MUST accept a max path
  // length of at least 128 bytes.
  string staging_target_path = 3;
}

message NodeGetVolumeStatsResponse {
  // This field is OPTIONAL.
  repeated VolumeUsage usage = 1;
  // Information about the current condition of the volume.
  // This field is OPTIONAL.
  // This field MUST be specified if the VOLUME_CONDITION node
  // capability is supported.
  VolumeCondition volume_condition = 2 [(alpha_field) = true];
}

message VolumeUsage {
  enum Unit {
    UNKNOWN = 0;
    BYTES = 1;
    INODES = 2;
  }
  // The available capacity in specified Unit. This field is OPTIONAL.
  // The value of this field MUST NOT be negative.
  int64 available = 1;

  // The total capacity in specified Unit. This field is REQUIRED.
  // The value of this field MUST NOT be negative.
  int64 total = 2;

  // The used capacity in specified Unit. This field is OPTIONAL.
  // The value of this field MUST NOT be negative.
  int64 used = 3;

  // Units by which values are measured. This field is REQUIRED.
  Unit unit = 4;
}

// VolumeCondition represents the current condition of a volume.
message VolumeCondition {
  option (alpha_message) = true;

  // Normal volumes are available for use and operating optimally.
  // An abnormal volume does not meet these criteria.
  // This field is REQUIRED.
  bool abnormal = 1;

  // The message describing the condition of the volume.
  // This field is REQUIRED.
  string message = 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;nodeexpandvolume&quot;&gt;NodeExpandVolume&lt;/h4&gt;
&lt;p&gt;此RPC调用允许CO扩展节点上的卷。此操作必须是幂等的。如果指定卷 ID对应的卷已经大于或等于扩展请求的目标容量，则插件应该回复&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 OK&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;NodeExpandVolume仅支持在给定的volume_path上扩展已经节点发布或节点暂存的卷。如果插件具有STAGE_UNSTAGE_VOLUME节点功能，则：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;NodeExpandVolume 必须在 NodeStageVolume 成功后调用。&lt;/li&gt;
  &lt;li&gt;NodeExpandVolume 可以在 NodePublishVolume 之前或之后调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;否则必须在 NodePublishVolume 成功后调用 NodeExpandVolume。&lt;/p&gt;

&lt;p&gt;如果插件只支持通过VolumeExpansion.OFFLINE功能扩展，那么卷必须首先脱机并通过ControllerExpandVolume扩展，然后在它可以在节点上扩展之前进行node-staged或 node-published通过 NodeExpandVolume。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;message NodeExpandVolumeRequest {
  // The ID of the volume. This field is REQUIRED.
  string volume_id = 1;

  // The path on which volume is available. This field is REQUIRED.
  // This field overrides the general CSI size limit.
  // SP SHOULD support the maximum path length allowed by the operating
  // system/filesystem, but, at a minimum, SP MUST accept a max path
  // length of at least 128 bytes.
  string volume_path = 2;

  // This allows CO to specify the capacity requirements of the volume
  // after expansion. If capacity_range is omitted then a plugin MAY
  // inspect the file system of the volume to determine the maximum
  // capacity to which the volume can be expanded. In such cases a
  // plugin MAY expand the volume to its maximum capacity.
  // This field is OPTIONAL.
  CapacityRange capacity_range = 3;

  // The path where the volume is staged, if the plugin has the
  // STAGE_UNSTAGE_VOLUME capability, otherwise empty.
  // If not empty, it MUST be an absolute path in the root
  // filesystem of the process serving this request.
  // This field is OPTIONAL.
  // This field overrides the general CSI size limit.
  // SP SHOULD support the maximum path length allowed by the operating
  // system/filesystem, but, at a minimum, SP MUST accept a max path
  // length of at least 128 bytes.
  string staging_target_path = 4;

  // Volume capability describing how the CO intends to use this volume.
  // This allows SP to determine if volume is being used as a block
  // device or mounted file system. For example - if volume is being
  // used as a block device the SP MAY choose to skip expanding the
  // filesystem in NodeExpandVolume implementation but still perform
  // rest of the housekeeping needed for expanding the volume. If
  // volume_capability is omitted the SP MAY determine
  // access_type from given volume_path for the volume and perform
  // node expansion. This is an OPTIONAL field.
  VolumeCapability volume_capability = 5;

  // Secrets required by plugin to complete node expand volume request.
  // This field is OPTIONAL. Refer to the `Secrets Requirements`
  // section on how to use this field.
  map&amp;lt;string, string&amp;gt; secrets = 6
    [(csi_secret) = true, (alpha_field) = true];
}

message NodeExpandVolumeResponse {
  // The capacity of the volume in bytes. This field is OPTIONAL.
  int64 capacity_bytes = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;

&lt;p&gt;Plugin会从环境变量&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CSI_ENDPOINT&lt;/code&gt;中获取需要监听的地址。CO也会从该变量中获取同Plugin通信的地址。一般流程如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Plugin获取已配置的环境变量&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CSI_ENDPOINT=unix:///path/to/unix/domain/socket.sock&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;CO从变量中获取同Plugin通信的sock &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unix:///path/to/unix/domain/socket.sock&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;CO监视该sock&lt;/li&gt;
  &lt;li&gt;Plugin创建该sock，绑定和监听该sock&lt;/li&gt;
  &lt;li&gt;CO观测到Sock已经存在，建立连接。调用接口&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GetPluginCapabilities&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Johan Wang</name><email>youhangwang@foxmail.com</email></author><category term="ContainerStorage" /><category term="Kubernetes" /><category term="CSI" /><summary type="html">CSI是一套存储产品通用的RPC接口。对于容器编排平台(CO)，支持CSI接口就意味可以支持多种存储厂商/类型；对于存储厂商，支持CSI接口就可以支持多平台，减少研发投入的同时扩宽市场。</summary></entry><entry><title type="html">Data Protection</title><link href="http://localhost:4000/2021/09/29/data-protection.html" rel="alternate" type="text/html" title="Data Protection" /><published>2021-09-29T00:00:00+08:00</published><updated>2021-09-29T00:00:00+08:00</updated><id>http://localhost:4000/2021/09/29/data-protection</id><content type="html" xml:base="http://localhost:4000/2021/09/29/data-protection.html">&lt;p&gt;数据保护的本质就是对当前数据进行备份，防止设备损坏或者其他各种原因导致数据丢失/不可访问，降低对于业务的影响。一旦发生问题，可以将备份的数据重新恢复到生产环境上，降低业务损失。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;从受保护的层级来说，数据保护可分为文件级保护和块级保护:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;文件级备份
    &lt;blockquote&gt;

      &lt;p&gt;文件级备份软件的基本机制，就是将数据以文件的形式读出，然后再将读出的文件存储在另外一个介质上。这些文件在原来的介质上，存放可以是不连续的，各个不连续的块之间的链关系由文件系统来管理。而如果备份软件将这些文件备份到新的空白介质上，那么这些文件很大程度上是连续存放的，不管是备份到磁带还是磁盘上。&lt;/p&gt;

      &lt;p&gt;优点：&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;ol&gt;
          &lt;li&gt;备份之后的数据一般都是连续存放的，消除碎片。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/blockquote&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;块级备份
    &lt;blockquote&gt;

      &lt;p&gt;所谓块级的备份，就是备份块设备上的每个块，不管这个块上有没有数据，或是这个块上的数据属于哪个文件。块级别的备份，不考虑也不用考虑文件系统层次的逻辑，原块设备有多少容量，就备份多少容量。块级的备份，是最底层的备份，它抛开了文件系统，直接对磁盘扇区进行读取，并将读取到的扇区写入新的磁盘对应的扇区。&lt;/p&gt;

      &lt;p&gt;优点：&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;ol&gt;
          &lt;li&gt;无需操作系统接管，通过磁盘控制器直接读取磁盘。资源消耗小，速度快。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/blockquote&gt;

      &lt;p&gt;缺点：&lt;/p&gt;
      &lt;blockquote&gt;
        &lt;ol&gt;
          &lt;li&gt;僵尸扇区，需要备份的扇区数量多。&lt;/li&gt;
          &lt;li&gt;备份/恢复的数据依旧是不连续储存的，碎片化严重。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/blockquote&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据保护的方法&quot;&gt;数据保护的方法&lt;/h2&gt;

&lt;p&gt;目前使用的数据保护方法基本有：远程文件复制、远程磁盘（卷）镜像、快照数据保护、卷Clone、CDP（Continue Data Protect）等。&lt;/p&gt;

&lt;h3 id=&quot;远程文件复制&quot;&gt;远程文件复制&lt;/h3&gt;

&lt;p&gt;远程文件复制方案，是把需要备份的文件，通过网络传输到异地容灾站点。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;优点：
    &lt;ul&gt;
      &lt;li&gt;可以只复制一个文件中变化过的内容，而不必整个文件都复制，这在同步大文件的时候非常管用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;远程磁盘镜像&quot;&gt;远程磁盘镜像&lt;/h3&gt;

&lt;p&gt;基于块的远程备份，即通过网络将备份的块数据传输到异地站点。具体可分为：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;同步复制
    &lt;blockquote&gt;
      &lt;p&gt;此方法需要等待远程备份写入成功之后才向上层返回结果。&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;优点：
          &lt;ul&gt;
            &lt;li&gt;可以保障数据一致性&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;缺点：
          &lt;ul&gt;
            &lt;li&gt;影响数据写入性能，对上层响应较慢&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;异步复制
    &lt;blockquote&gt;
      &lt;p&gt;此方法无需等待远程备份的写入结果，由后台向远程备份写入数据。&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;优点：
          &lt;ul&gt;
            &lt;li&gt;对上层响应较快&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;缺点：
          &lt;ul&gt;
            &lt;li&gt;不能保障数据一致性&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;快照数据保护&quot;&gt;快照数据保护&lt;/h3&gt;

&lt;p&gt;数据在存储的过程中是不断在变化的，如果有办法能够将某一时刻所存储的数据留底，一旦数据污染，则可以将数据回滚至留底那一时刻的状态，从这一时间点重新来过，类似于游戏中的存档点。从快照的受体来说，快照技术可分为基于文件系统的快照和基于物理卷的快照。&lt;/p&gt;

&lt;h4 id=&quot;基于文件系统的快照&quot;&gt;基于文件系统的快照&lt;/h4&gt;

&lt;p&gt;快照，顾名思义需要在很短的时间内获取当前时刻的全部内容。对于保存在存储介质的上的数据来说，如何能在非常短的时间内创建一份快照呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;只复制数据的元数据链&lt;/li&gt;
  &lt;li&gt;通过RoFW（Redirect on First Write）或者CoFW（Copy on First Write）保证源数据的更改不会影响快照中的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;基于物理卷的快照&quot;&gt;基于物理卷的快照&lt;/h4&gt;

&lt;p&gt;类似于文件系统的快照，可以复制LUN的映射元数据链，使用RoFW或者CoFW保障原始数据的更改不会影响快照数据。&lt;/p&gt;

&lt;h3 id=&quot;卷clone&quot;&gt;卷Clone&lt;/h3&gt;

&lt;p&gt;不同于快照，clone是某一时间点数据的实体复制。可以先对数据做snapshot，在将snapshot中的数据复制出来到一个额外的存储空间。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;虚Clone&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本质上就是一个可写的snapshot，这份clone没有被更改的部分是与原数据共享的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实Clone&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一份真实的数据实体。&lt;/p&gt;

&lt;h3 id=&quot;continuous-data-protectcdp连续数据保护&quot;&gt;Continuous Data Protect（CDP，连续数据保护）&lt;/h3&gt;

&lt;p&gt;CDP（持续数据保护）是一种在不影响主要数据运行的前提下，可以实现持续捕捉或跟踪目标数据所发生的任何改变，并且能够恢复到此前任意时间点的方法。CDP系统能够提供块级、文件级和应用级的备份。&lt;/p&gt;

&lt;h4 id=&quot;应用级cdp&quot;&gt;应用级CDP&lt;/h4&gt;

&lt;p&gt;CDP发生在应用程序中，应用程序自己对自己产生的数据加以连续的保护。其中典型的例子是各种数据库产品，数据库会对每一笔交易做日志记录，所有的操作都会打上时间戳并记录到日志中。当数据库发生问题的时候，利用归档的日志，可以将数据库的状态恢复至任意时间点。数据库会顺序读出库中的每一笔交易然后将其重放（Replay），对应的数据重新写入数据库文件。重放完成后，还需要进行Redo和Undo操作，即检查日志中最后一个CheckPoint一致点处，一致点之后发生的交易全部回退。回退完成后，数据库便处于一个一致的状态并且可用。&lt;/p&gt;

&lt;h4 id=&quot;文件级cdp&quot;&gt;文件级CDP&lt;/h4&gt;

&lt;p&gt;文件级CDP就是通过监视文件系统动作，文件的每一次变化（包括实际数据或者元数据的变化，比如重命名、删除、裁剪等属性的改变）以日志的形式被记录下来。CDP引擎分析应用对文件系统的IO数据流，然后计算出文件变化的部分，将其保存在CDP仓库设备（存放CDP数据的介质）中，可以针对每个文件生成单独的日志链。可以对一个文件，或者一个目录，甚至一个卷来监控。文件级的CDP方案，一般需要在生产主机上安装代理，用来监控文件系统IO，并将变化的数据信息传送到CDP仓库介质中，或者使用本地文件系统或者磁盘的某块额外空间来充当日志仓库。文件级的CDP，能够保证数据的一致性。因为它是作用于文件系统层次，捕获的是完整事务操作。所有的文件版本管理软件都可以算作是文件级CDP的实现。&lt;/p&gt;

&lt;h4 id=&quot;块级cdp&quot;&gt;块级CDP&lt;/h4&gt;

&lt;p&gt;块级的CDP，与应用级和文件级CDP实现思想相同，其实就是捕获底层卷的写IO变化，并将每次变化的块数据打入时间戳并且保存下来。&lt;/p&gt;

&lt;h3 id=&quot;volume-shadow-copy-servicevss公共快照服务&quot;&gt;Volume Shadow Copy Service(VSS)公共快照服务&lt;/h3&gt;

&lt;p&gt;为了保证Snapshot的一致性，几乎所有存储厂商都提供了自己开发的针对各种应用程序和文件系统的代理模块。而应用程序有无限多种，存储厂商也有多个，但是这些应用以及存储代理都运行在同一个操作系统中，与其每一个厂商为每一种应用程序都开发自己的代理，不如在操作系统中建立一个公共的Framework服务，往上适配各种应用程序，往下则适配各厂商的代理，做到统一控制调配，统一开发接口。微软在其Windows Server操作系统中就提供了这样一种公共服务模块。VSS为不同的应用和不同的快照代理提供了一个公共Framework，极大简化了系统的复杂性。&lt;/p&gt;

&lt;h2 id=&quot;数据的一致性&quot;&gt;数据的一致性&lt;/h2&gt;

&lt;p&gt;业界对备份一致性的定义包括如下三类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;不一致备份：文件或磁盘数据的备份，不在同一时间点产生。&lt;/li&gt;
  &lt;li&gt;崩溃一致性备份：云服务器中文件或磁盘数据的备份，在同一时间点产生，但不会静默数据库等应用系统、不会备份内存数据，不保证应用系统备份的一致性。&lt;/li&gt;
  &lt;li&gt;应用一致性备份：文件/磁盘数据在同一时间点，并静默数据库刷新内存数据，保证应用系统备份的一致性。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Johan Wang</name><email>youhangwang@foxmail.com</email></author><category term="Storage" /><category term="DataProtection" /><summary type="html">数据保护的本质就是对当前数据进行备份，防止设备损坏或者其他各种原因导致数据丢失/不可访问，降低对于业务的影响。一旦发生问题，可以将备份的数据重新恢复到生产环境上，降低业务损失。</summary></entry><entry><title type="html">golang rpc package分析</title><link href="http://localhost:4000/2019/03/30/golang-rpc-package.html" rel="alternate" type="text/html" title="golang rpc package分析" /><published>2019-03-30T00:00:00+08:00</published><updated>2019-03-30T00:00:00+08:00</updated><id>http://localhost:4000/2019/03/30/golang-rpc-package</id><content type="html" xml:base="http://localhost:4000/2019/03/30/golang-rpc-package.html">&lt;p&gt;​最近，由于微服务概念的流行又将RPC这一概念重新带回开发者的视野中，相比构建于HTTP协议之上的RESTful API来讲，RPC通常会构建于tcp协议之上。&lt;!--more--&gt;由于避免了一些HTTP协议的缺点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;HTTP是无状态的，导致每次通信会有过于冗余的header。&lt;/li&gt;
  &lt;li&gt;短链接。HTTP/1.0默认使用短连接，每次通信都会重新发送TCP链接请求，而TCP连接建立时会有一系列握手动作。即使在1.1中默认使用的了长连接，但是该模式下的pipeline依然会存在HOLB问题。同时由于TCP协议的拥塞控制总是慢开始，也会导致性能的下降。&lt;/li&gt;
  &lt;li&gt;文本传输。HTTP使用文本传输，效率低。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;所以rpc的效率通常会比RESTful API高一些，可以节省服务器资源，尤其是对于各个服务之间需要频繁通信的场景。当然，上述HTTP的缺点已经在HTTP/2中解决了。在grpc框架里，google采用的rpc over http/2的解决方案。所以在HTTP/2时代中，个人认为，RESTful API和rpc的性能已经基本没有差距。主要应该是在编程风格的差异上。&lt;/p&gt;

&lt;p&gt;废话不多说，直接看code。在MacOS下，rpc包位于/usr/local/go/src/net/rpc，我们先从Client看起。&lt;/p&gt;

&lt;h2 id=&quot;client&quot;&gt;Client&lt;/h2&gt;
&lt;p&gt;在Client中，package提供了三个函数：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;func DialHTTP(network, address string) (*Client, error)&lt;/li&gt;
  &lt;li&gt;func DialHTTPPath(network, address, path string) (*Client, error)&lt;/li&gt;
  &lt;li&gt;func Dial(network, address string) (*Client, error)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DialHTTP&lt;/code&gt;使用了默认的 path /&lt;em&gt;goRPC&lt;/em&gt; 调用http connect方法建立隧道。这里只是使用HTTP的connect方法建立隧道连接，与RESTful API还是有区别的：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;io.WriteString(conn, &quot;CONNECT &quot;+path+&quot; HTTP/1.0\n\n&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而Dial则是单纯的建立一条TCP连接。&lt;/p&gt;

&lt;p&gt;建立conn之后就是创建一个rpc client。rpc client的定义如下。主要包含一下几个内容：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;编解码器&lt;/li&gt;
  &lt;li&gt;request：包括调用的method，请求的编号和一个指针。&lt;/li&gt;
  &lt;li&gt;seq：请求的编号&lt;/li&gt;
  &lt;li&gt;pending-map：存放着发送出去但是还没有response的call&lt;/li&gt;
  &lt;li&gt;closing，shutdown：client的两种状态&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里的Call和Requst有一些不同。Call指的是一次完整的调用，包含的信息更多。比如本次调用的参数，需要返回的内容和一个能够接受返回内容的channel。如果是非同步调用，该channel必须是buffered。而request只是代表一次请求，内容只有请求的方法，编号和一个指针。这个指针在Client里没有使用，在server端code的分析中我们会再来讨论。除此之外，这里还有两把锁，负责并发下不同的控制粒度。第一把锁reqMutex sync.Mutex可以叫做方法锁，一个client可以并发的发送request，所以它在发送request的时候会被使用。第二把锁mutex sync.Mutex 是map锁，同java一样，go中的map也是非线程安全的。在并发条件下对map进行操作需要上锁。在发送请求的方法中，每发送一个请求就会向pending-map里面添加一个Call。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Client represents an RPC Client.
// There may be multiple outstanding Calls associated
// with a single Client, and a Client may be used by
// multiple goroutines simultaneously.
type Client struct {
    codec ClientCodec

    reqMutex sync.Mutex // protects following
    request  Request

    mutex    sync.Mutex // protects following
    seq      uint64
    pending  map[uint64]*Call
    closing  bool // user has called Close
    shutdown bool // server has told us to stop
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;rpc client中还包含一个编解码器，默认情况下会使用gob进行编解码：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func NewClient(conn io.ReadWriteCloser) *Client {
    encBuf := bufio.NewWriter(conn)
    client := &amp;amp;gobClientCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(encBuf), encBuf}
    return NewClientWithCodec(client)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;rpc client初始化完成之后会闯将一个pending-map，并新起一个协程client.input()监听server端的response：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func NewClientWithCodec(codec ClientCodec) *Client {
    client := &amp;amp;Client{
        codec:   codec,
        pending: make(map[uint64]*Call),
    }
    go client.input()
    return client
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个协程中，一个for循环不断的监听server的response，直到发生error为止。response分为两个部分：header和body。header中主要包含两个信息：serviceMethod和一个序列号。这个序列号对应着一个call。首先，client需要解析header。还记得之前初始化的gob client吗？对的，这里需要编解码器的解码。拿到header之后的第一件事就是取出序列号seq。拿到序列号之后去client的pending map中找到对应的call。接着将 body解析到该call中的reply中。并将call放入channel中。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (client *Client) input() {
    var err error
    var response Response
    for err == nil {
        response = Response{}
        err = client.codec.ReadResponseHeader(&amp;amp;response)
        if err != nil {
            break
        }
        seq := response.Seq
        client.mutex.Lock()
        call := client.pending[seq]
        delete(client.pending, seq)
        client.mutex.Unlock()

        switch {
        case call == nil:
            // We&apos;ve got no pending call. That usually means that
            // WriteRequest partially failed, and call was already
            // removed; response is a server telling us about an
            // error reading request body. We should still attempt
            // to read error body, but there&apos;s no one to give it to.
            err = client.codec.ReadResponseBody(nil)
            if err != nil {
                err = errors.New(&quot;reading error body: &quot; + err.Error())
            }
        case response.Error != &quot;&quot;:
            // We&apos;ve got an error response. Give this to the request;
            // any subsequent requests will get the ReadResponseBody
            // error if there is one.
            call.Error = ServerError(response.Error)
            err = client.codec.ReadResponseBody(nil)
            if err != nil {
                err = errors.New(&quot;reading error body: &quot; + err.Error())
            }
            call.done()
        default:
            err = client.codec.ReadResponseBody(call.Reply)
            if err != nil {
                call.Error = errors.New(&quot;reading body &quot; + err.Error())
            }
            call.done()
        }
    }
    // Terminate pending calls.
    client.reqMutex.Lock()
    client.mutex.Lock()
    client.shutdown = true
    closing := client.closing
    if err == io.EOF {
        if closing {
            err = ErrShutdown
        } else {
            err = io.ErrUnexpectedEOF
        }
    }
    for _, call := range client.pending {
        call.Error = err
        call.done()
    }
    client.mutex.Unlock()
    client.reqMutex.Unlock()
    if debugLog &amp;amp;&amp;amp; err != io.EOF &amp;amp;&amp;amp; !closing {
        log.Println(&quot;rpc: client protocol error:&quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上部分就是初始化client的code。接下来是client发送请求的code.&lt;/p&gt;

&lt;p&gt;rpc package提供了两个方法：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call 
func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Call是同步调用，Go是异步调用。其中Call只是使用了一个non-buffered channel去阻塞的调用Go方法，实现同步调用：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Call invokes the named function, waits for it to complete, and returns its error status.
func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) error {
    call := &amp;lt;-client.Go(serviceMethod, args, reply, make(chan *Call, 1)).Done
    return call.Error
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Go方法中使用参数初始化call，并调用send方法。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;call := new(Call)
call.ServiceMethod = serviceMethod
call.Args = args
call.Reply = reply

done = make(chan *Call, 10)
call.Done = done
client.send(call)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在sent中初始化request，并且将call放入pending map中发送调用请求：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (client *Client) send(call *Call) {
    client.reqMutex.Lock()
    defer client.reqMutex.Unlock()

    // Register this call.
    client.mutex.Lock()
    if client.shutdown || client.closing {
        client.mutex.Unlock()
        call.Error = ErrShutdown
        call.done()
        return
    }
    seq := client.seq
    client.seq++
    client.pending[seq] = call
    client.mutex.Unlock()

    // Encode and send the request.
    client.request.Seq = seq
    client.request.ServiceMethod = call.ServiceMethod
    err := client.codec.WriteRequest(&amp;amp;client.request, call.Args)
    if err != nil {
        client.mutex.Lock()
        call = client.pending[seq]
        delete(client.pending, seq)
        client.mutex.Unlock()
        if call != nil {
            call.Error = err
            call.done()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;server&quot;&gt;Server&lt;/h2&gt;
&lt;p&gt;我们再来看server端的code，rpc包中给了两个函数：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Register publishes the receiver&apos;s methods in the DefaultServer.
func Register(rcvr interface{}) error { return DefaultServer.Register(rcvr) }

// RegisterName is like Register but uses the provided name for the type
// instead of the receiver&apos;s concrete type.
func RegisterName(name string, rcvr interface{}) error {
    return DefaultServer.RegisterName(name, rcvr)
}
      他们用来将服务注册到rpc server。其中Register会使用服务的类型名来充当服务的名字，而RegisterName则会使用自定义的服务名。在register方法中，会检查服务以及服务提供的方法是否满足要求：比如参数类型，是否是外部可见的变量。并且创建一个service对象：
func (server *Server) register(rcvr interface{}, name string, useName bool) error {
    s := new(service)
    s.typ = reflect.TypeOf(rcvr)
    s.rcvr = reflect.ValueOf(rcvr)
    sname := reflect.Indirect(s.rcvr).Type().Name()
    if useName {
        sname = name
    }
    if sname == &quot;&quot; {
        s := &quot;rpc.Register: no service name for type &quot; + s.typ.String()
        log.Print(s)
        return errors.New(s)
    }
    if !isExported(sname) &amp;amp;&amp;amp; !useName {
        s := &quot;rpc.Register: type &quot; + sname + &quot; is not exported&quot;
        log.Print(s)
        return errors.New(s)
    }
    s.name = sname

    // Install the methods
    s.method = suitableMethods(s.typ, true)

    if len(s.method) == 0 {
        str := &quot;&quot;

        // To help the user, see if a pointer receiver would work.
        method := suitableMethods(reflect.PtrTo(s.typ), false)
        if len(method) != 0 {
            str = &quot;rpc.Register: type &quot; + sname + &quot; has no exported methods of suitable type (hint: pass a pointer to value of that type)&quot;
        } else {
            str = &quot;rpc.Register: type &quot; + sname + &quot; has no exported methods of suitable type&quot;
        }
        log.Print(str)
        return errors.New(str)
    }

    if _, dup := server.serviceMap.LoadOrStore(sname, s); dup {
        return errors.New(&quot;rpc: service already defined: &quot; + sname)
    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注册完service之后，就可以调用Package提供的HandleHTTP方法了，这个方法实际上在调用http包提供的handle方法：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (server *Server) HandleHTTP(rpcPath, debugPath string) {
    http.Handle(rpcPath, server)
    http.Handle(debugPath, debugHTTP{server})
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在ServeHTTP方法中，server会使用Hijack()将HTTP对应的TCP连接取出。对client的connect方法作出回应：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ServeHTTP implements an http.Handler that answers RPC requests.
func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    if req.Method != &quot;CONNECT&quot; {
        w.Header().Set(&quot;Content-Type&quot;, &quot;text/plain; charset=utf-8&quot;)
        w.WriteHeader(http.StatusMethodNotAllowed)
        io.WriteString(w, &quot;405 must CONNECT\n&quot;)
        return
    }
    conn, _, err := w.(http.Hijacker).Hijack()
    if err != nil {
        log.Print(&quot;rpc hijacking &quot;, req.RemoteAddr, &quot;: &quot;, err.Error())
        return
    }
    io.WriteString(conn, &quot;HTTP/1.0 &quot;+connected+&quot;\n\n&quot;)
    server.ServeConn(conn)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;拿到connection之后就可以开始初始化server的编解码器了：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (server *Server) ServeConn(conn io.ReadWriteCloser) {
    buf := bufio.NewWriter(conn)
    srv := &amp;amp;gobServerCodec{
        rwc:    conn,
        dec:    gob.NewDecoder(conn),
        enc:    gob.NewEncoder(buf),
        encBuf: buf,
    }
    server.ServeCodec(srv)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从connection中解码request。同样分成两个部分header和body。还记得 client部分request有一个指针吗？server端每次解析request的时候，如果freeReq中没有现成的request，就去堆中申请。使用完之后并不交给GC回收，而是使用表链的结构将其添加到freeReq中，这样可以减少go GC的调用。response的申请和取消也是一样的。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (server *Server) getRequest() *Request {
    server.reqLock.Lock()
    req := server.freeReq
    if req == nil {
        req = new(Request)
    } else {
        server.freeReq = req.next
        *req = Request{}
    }
    server.reqLock.Unlock()
    return req
}
func (server *Server) freeRequest(req *Request) {
    server.reqLock.Lock()
    req.next = server.freeReq
    server.freeReq = req
    server.reqLock.Unlock()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;拿到request header之后，从其中取出service和mothod name，并拿到相应的method：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (server *Server) readRequestHeader(codec ServerCodec) (svc *service, mtype *methodType, req *Request, keepReading bool, err error) {
    // Grab the request header.
    req = server.getRequest()
    err = codec.ReadRequestHeader(req)
    if err != nil {
      ....

    }

    // We read the header successfully. If we see an error now,
    // we can still recover and move on to the next request.
    keepReading = true

    dot := strings.LastIndex(req.ServiceMethod, &quot;.&quot;)
    if dot &amp;lt; 0 {
        err = errors.New(&quot;rpc: service/method request ill-formed: &quot; + req.ServiceMethod)
        return
    }
    serviceName := req.ServiceMethod[:dot]
    methodName := req.ServiceMethod[dot+1:]

    // Look up the request.
    svci, ok := server.serviceMap.Load(serviceName)
    if !ok {
        err = errors.New(&quot;rpc: can&apos;t find service &quot; + req.ServiceMethod)
        return
    }
    svc = svci.(*service)
    mtype = svc.method[methodName]
    if mtype == nil {
        err = errors.New(&quot;rpc: can&apos;t find method &quot; + req.ServiceMethod)
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;读取完request就可以调用service的call方法了，实际上是使用反射执行service的相应方法：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (s *service) call(server *Server, sending *sync.Mutex, wg *sync.WaitGroup, mtype *methodType, req *Request, argv, replyv reflect.Value, codec ServerCodec) {
    if wg != nil {
        defer wg.Done()
    }
    mtype.Lock()
    mtype.numCalls++
    mtype.Unlock()
    function := mtype.method.Func
    // Invoke the method, providing a new value for the reply.
    returnValues := function.Call([]reflect.Value{s.rcvr, argv, replyv})
    // The return value for the method is an error.
    errInter := returnValues[0].Interface()
    errmsg := &quot;&quot;
    if errInter != nil {
        errmsg = errInter.(error).Error()
    }
    server.sendResponse(sending, req, replyv.Interface(), codec, errmsg)
    server.freeRequest(req)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后调用sendResponse方法返回response：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func (server *Server) sendResponse(sending *sync.Mutex, req *Request, reply interface{}, codec ServerCodec, errmsg string) {
    resp := server.getResponse()
    // Encode the response header
    resp.ServiceMethod = req.ServiceMethod
    if errmsg != &quot;&quot; {
        resp.Error = errmsg
        reply = invalidRequest
    }
    resp.Seq = req.Seq
    sending.Lock()
    err := codec.WriteResponse(resp, reply)
    if debugLog &amp;amp;&amp;amp; err != nil {
        log.Println(&quot;rpc: writing response:&quot;, err)
    }
    sending.Unlock()
    server.freeResponse(resp)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上就是golang中rpc包的源码分析。由于golang天生对于高并发的支持，可以在很少工作量的前提下实现一个高性能的server。最近也在看http的源码，有机会再做笔记。&lt;/p&gt;</content><author><name>Johan Wang</name><email>youhangwang@foxmail.com</email></author><category term="golang" /><category term="rpc" /><summary type="html">​最近，由于微服务概念的流行又将RPC这一概念重新带回开发者的视野中，相比构建于HTTP协议之上的RESTful API来讲，RPC通常会构建于tcp协议之上。</summary></entry></feed>