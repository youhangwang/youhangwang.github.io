---
title: Container Storage Interface（CSI) In Kubernetes
tags: ContainerStorage Kubernetes CSI 
--- 

[CSI](./2021-10-29-CSI.md)是一套通用的RPC接口，可以将Block和File System暴露给Kubernetes等容器编排系统(CO)上的容器化工作负载。通过使用CSI，第三方存储提供商可以编写和部署插件，在Kubernetes中公开新的存储系统，而无需接触Kubernetes的核心代码。
<!--more-->


## Development And Deployment

[container-storage-interface-drivers-announce](https://groups.google.com/forum/#!forum/container-storage-interface-drivers-announce)会发布可能影响现有CSI Driver实现的CSI或Kubernetes的更改。

Kubernetes没有具体规定如何打包和部署CSI Driver，但是对Kubernetes（Master和Node）组件如何找到CSI Driver并与之通信规定了以下内容：

- Kubelet与CSI Driver的通信:
  - Kubelet通过插件注册机制发现 CSI Driver（以及用于与 CSI Driver交互的 Unix 域套接字）。
  - Kubelet通过Unix Domain Socket直接向CSI Driver发出调用（如 NodeStageVolume、NodePublishVolume 等）以挂载和卸载卷。

- Master与CSI Driver的通信:
  - Kubernetes Master组件不与CSI Driver直接通信（例如通过 Unix 域套接字或其他方式）。
  - Kubernetes Master组件仅与Kubernetes API交互。
  - 因此，基于Kubernetes API的操作（如卷创建、卷附加、卷快照等）的CSI Driver必须监视Kubernetes API并触发适当的CSI操作。

这些要求是最低限度的规定，CSI Driver开发人员可以自由地实施和部署他们认为合适的Driver。但是为了简化开发和部署，推荐使用下面描述的机制：

使用以下组件开发CSI Driver：
- Kubernetes CSI Sidecar 容器
- Kubernetes CSI 对象
- CSI Driver测试工具

要使用此机制实现CSI Driver，CSI Driver开发人员应该：
1. 创建一个容器化应用程序，实现CSI规范中定义的Identify、Node Service和可选的Controller Service。
2. 使用csi-sanity进行单元测试。
3. 定义Kubernetes API YAML 文件，用于部署 CSI Driver和适当的Sidecar Container。
4. 在Kubernetes集群上部署CSI Driver并在其上运行E2E功能测试。

## Overview
创建CSI Driver的第一步是编写实现CSI Spec中描述gRPC接口的应用程序，CSI Driver至少须实现以下两种CSI服务：
- CSI Identity
  - 使调用者（Kubernetes组件和CSI sidecar container）能够识别Driver及其支持的可选功能。
- CSI Node Service
  - 仅其中的NodePublishVolume、NodeUnpublishVolume和NodeGetCapabilities是必须实现的。
  - 必需的方法使调用者能够在指定的路径上提供可用的Volume并发现Driver支持哪些可选功能。

所有CSI服务都可以在同一个CSI Driver应用程序中实现。CSI Driver应用程序应该被容器化，以便在Kubernetes上轻松部署。容器化后，CSI Driver可以与CSI Sidecar Containers配对，并根据需要以Node和/或Controller模式部署。如果Driver支持附加功能，CSI capabilities可用于告知调用者它支持的可选方法/服务，例如：

- CONTROLLER_SERVICE（PluginCapability）
  - 整个CSI Controller Service是可选的。此功能指示Driver实现了CSI Controller Service中的一个或多个方法。
- VOLUME_ACCESSIBILITY_CONSTRAINTS（PluginCapability）
  - 此功能表明该Driver支持的Volume可能无法从集群中的所有节点同等访问，并且该Driver将返回额外的拓扑相关信息，Kubernetes 可以使用这些信息更智能地调度工作负载或影响配置Volume的位置。
- VolumeExpansion (PluginCapability)
  - 此功能表明Driver支持在创建后调整（扩展）卷的大小。
- CREATE_DELETE_VOLUME（ControllerServiceCapability）
  - 此功能表明Driver支持动态卷配置和删除。
- PUBLISH_UNPUBLISH_VOLUME（ControllerServiceCapability）
  - 此功能表明Driver实现了ControllerPublishVolume和ControllerUnpublishVolume —— 对应于 Kubernetes 卷附加/分离操作的操作。例如，这可能会导致针对 Google Cloud 控制平面的“卷附加”操作，以将指定卷附加到 Google Cloud PD CSI Driver的指定节点。
- CREATE_DELETE_SNAPSHOT (ControllerServiceCapability)
  - 此功能表明Driver支持供应卷快照以及使用这些快照供应新卷的能力。
- CLONE_VOLUME（ControllerServiceCapability）
  - 此功能表明Driver支持克隆卷。
- STAGE_UNSTAGE_VOLUME（NodeServiceCapability）
  - 此功能表明Driver实现了NodeStageVolume 和NodeUnstageVolume —— 对应于 Kubernetes 卷设备挂载/卸载操作的操作。例如，这可以用于创建块存储设备的全局（每个节点）卷安装。

## Kubernetes CSI Sidecar Containers

Kubernetes CSI Sidecar Containers是一组标准容器，目标是简化Kubernetes上CSI驱动程序的开发和部署。这些容器包含Watch Kubernetes API 的通用逻辑，触发针对CSI Driver容器的适当操作，并根据需要更新 Kubernetes API。使用这些Sider Car的好处包括：
1. CSI Driver开发人员不必担心复杂的Kubernetes代码。
2. 与 Kubernetes API 交互的代码与实现 CSI 接口的代码隔离（在不同的容器中）。

Kubernetes 开发团队维护以下 Kubernetes CSI Sidecar Containers：

### [external-provisioner](https://github.com/kubernetes-csi/external-provisioner)
CSI external-provisioner 是一个 sidecar 容器，用于监视 Kubernetes Apiserver 以获取 PersistentVolumeClaim 对象。它调用指定的 CSI Driver的CreateVolume接口以供应新卷或者DeleteVolume删除卷。在 Kubernetes controller-manager中运行的内部persistent volume controller没有任何与 CSI 驱动程序的直接接口。

如果PVC引用了StorageClass，并且StorageClass的Provisioner字段与GetPluginInfo接口中返回的名称匹配，则卷由PersistentVolumeClaim对象的创建触发。当成功配置新卷后，sidecar容器会创建一个 Kubernetes PersistentVolume 对象来表示该卷。

一旦与此PersistentVolume绑定了PersistentVolumeClaim被删除，对应CSI driver的DeleteVolume接口会被调用。当该卷被成功删除时，sider car也会删除代表该卷的PersistentVolume对象。

#### Data Source

external-provisioner提供了从一个data source部署volume的能力。支持的data source 包括：

1. Snapshot
  如果将Snapshot CRD 指定为 PVC 对象上的数据源，则sider car通过获取`SnapshotContent`对象来获取有关快照的信息，并在调用`CreateVolume`时填充data source字段以向存储系统指示新卷应使用指定的快照填充。

2. PersistentVolumeClaim(clone)
  克隆也是通过在`CreateVolume`调用中的`DataSource`字段中指定一种类型为`PersistentVolumeClaim`的`kind`来实现的。外部供应商有责任验证在 DataSource 中指定的对象是否存在，是否与正在供应的卷在同一存储类中，并且当前状态是绑定的。

#### StorageClass 参数
Provision新卷时，CSI external-provisioner将`CreateVolumeRequest`调用中的parameters(map<string, string>)字段设置为它正在处理的 StorageClass中指定的键/值。

CSI external-provisioner (v1.0.1+) 还保留了前缀为 csi.storage.k8s.io/ 的参数键。任何以 csi.storage.k8s.io/ 为前缀的 StorageClass 键都不会传递给 CSI Driver。y

以下保留的 StorageClass 参数键会触发 CSI external-provisioner的行为：
- csi.storage.k8s.io/provisioner-secret-name
- csi.storage.k8s.io/provisioner-secret-namespace
- csi.storage.k8s.io/controller-publish-secret-name
- csi.storage.k8s.io/controller-publish-secret-namespace
- csi.storage.k8s.io/node-stage-secret-name
- csi.storage.k8s.io/node-stage-secret-namespace
- csi.storage.k8s.io/node-publish-secret-name
- csi.storage.k8s.io/node-publish-secret-namespace
- csi.storage.k8s.io/fstype

#### PersistentVolumeClaim and PersistentVolume 参数

CSI external-provisioner (v1.6.0+) 引入了 --extra-create-metadata 标志，它会在 CSI CreateVolumeRequest 中自动设置以下的parameters(map<string, string>)：

- csi.storage.k8s.io/pvc/name
- csi.storage.k8s.io/pvc/namespace
- csi.storage.k8s.io/pv/name

这些参数不是 StorageClass 的一部分，而是使用源 PersistentVolumeClaim 和 PersistentVolume 的名称和命名空间在内部生成的。

#### [使用](https://github.com/kubernetes-csi/external-provisioner/blob/master/README.md)
支持动态卷Provision的 CSI driver应该使用这个 sidecar 容器，并向外告知CSI CREATE_DELETE_VOLUME的控制器功能被支持。

external-provisioner 可以与其他外部 CSI 控制器（例如 external-attacher、external-snapshotter 和/或 external-resizer）在同一个 pod 中运行。请注意，external-provisioner 不会随着更多副本进行扩展。只有一个外部供应者被选为leader并运行。其replica等待leader 失效。他们在leader失效后约 15 秒内重新选举新的active leader。

### external-resizer

CSI external-resizer负责Watch PersistentVolumeClaim对象的更改，如果用户需要更多的Storage，则会调用`ControllerExpandVolume`接口。
#### 使用

支持Kubernetes volume expansion的 CSI driver应该使用这个 sidecar 容器，并向外告知CSI VolumeExpansion的控制器功能被支持。

### external-attacher

CSI external-attacher负责Watch VolumeAttachment对象并调用`Controller[Publish|Unpublish]Volume`接口。

#### [使用](https://github.com/kubernetes-csi/external-attacher/blob/master/README.md)

支持Kubernetes volume attach/detach的 CSI driver应该使用这个 sidecar 容器，并向外告知CSI PUBLISH_UNPUBLISH_VOLUME的控制器功能被支持。

### node-driver-registrar
CSI node-driver-registrar通过调用CSI driver的NodeGetInfo接口获取信息，并使用Kubelet[插件注册](https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/pluginmanager/pluginwatcher/README.md)机制向该node上的Kubelet组册CSI driver。

#### 使用

Kubelet 直接针对 CSI driver发起 CSI NodeGetInfo、NodeStageVolume 和 NodePublishVolume 调用。它使用 kubelet 插件注册机制来发现 unix 域套接字以与 CSI driver对话。因此，所有 CSI driver都应该使用这个 sidecar 容器向 kubelet 注册自己。


### external-snapshotter


### livenessprobe


CSI livenessprobe 是一个 sidecar 容器，它监控 CSI driver 的健康状况，并通过 Liveness Probe 机制将其报告给 Kubernetes。这使 Kubernetes 能够自动检测驱动程序的问题并重新启动 pod 以尝试修复问题。


liveness probe 是一个 sidecar 容器，它暴露了一个 HTTP /healthz 端点，它作为 kubelet 的 livenessProbe 钩子来监控 CSI 驱动程序的健康状况。

活性探针使用 Probe() 调用来检查 CSI 驱动程序是否健康。有关 Probe API 调用的更多信息，请参阅 CSI 规范。容器存储接口 (CSI)

### external-health-monitor-controller
CSI external-health-monitor-controller 是一个 sidecar 容器，与 CSI 控制器驱动程序一起部署，类似于 CSI external-provisioner sidecar 的部署方式。它调用 CSI 控制器 RPC ListVolumes 或 ControllerGetVolume 来检查 CSI 卷的健康状况，如果卷的状况异常，则在 PersistentVolumeClaim 上报告事件。

CSI external-health-monitor-controller 还监视节点故障事件。可以通过将 enable-node-watcher 标志设置为 true 来启用此组件。这现在只会对本地 PV 产生影响。当检测到节点故障事件时，会在 PVC 上报告一个事件，表明使用该 PVC 的 Pod 位于故障节点上。

#### 使用

支持 VOLUME_CONDITION 和 LIST_VOLUMES 或 VOLUME_CONDITION 和 GET_VOLUME 控制器功能的 CSI 驱动程序应该使用这个 sidecar 容器。